<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Opencv系列（二）</title>
      <link href="/2023/04/02/opencv2/"/>
      <url>/2023/04/02/opencv2/</url>
      
        <content type="html"><![CDATA[<h1 id="Opencv图像滤波"><a href="#Opencv图像滤波" class="headerlink" title="Opencv图像滤波"></a>Opencv图像滤波</h1><h2 id="连通域-amp-直方图"><a href="#连通域-amp-直方图" class="headerlink" title="连通域&amp;直方图"></a>连通域&amp;直方图</h2><p><img src="/pic/%E9%80%89%E5%8C%BA_042.png"></p><p><strong>计算图像直方图</strong></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void cv::calcHist(       const Mat *     images,           &#x2F;&#x2F;输入图像    int     nimages,                  &#x2F;&#x2F;源图像的个数（通常为1）    const int *     channels,         &#x2F;&#x2F;列出通道    InputArray  mask,                 &#x2F;&#x2F;输入掩码（需处理的像素）    OutputArray     hist,             &#x2F;&#x2F;输出直方图    int     dims,                     &#x2F;&#x2F;直方图的维度（通道数量）    const int *     histSize,         &#x2F;&#x2F;每个维度位数    const float **  ranges,           &#x2F;&#x2F;每个维度的范围    bool    uniform &#x3D; true,           &#x2F;&#x2F;true表示箱子间距相同    bool    accumulate &#x3D; false        &#x2F;&#x2F;是否在多次调用时进行累积    )<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>二值函数</strong></p><p>cv::threshold()</p><blockquote><p>〖原理〗：通过将所有像素与某个阈值（第三个参数）进行比较赋值，将图像表示为只有两种像素值的图像（例子：学生排队）。</p></blockquote><p>阈值是图像分割的标尺。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;opencv2&#x2F;imgproc.hpp&gt;&#x2F;&#x2F;创建二值图像double cv::threshold(       InputArray  src,          &#x2F;&#x2F;输入图像（多通道、8位或32位浮点类型）       OutputArray     dst,      &#x2F;&#x2F;输出图像    double  thresh,           &#x2F;&#x2F;指定阈值    double  maxval,           &#x2F;&#x2F;设定最大值（常取255）    int     type              &#x2F;&#x2F;阈值类型    )&#x2F;*type，详见参数介绍1、THRESH_BINARY：将所有大于thresh的像素赋值为maxval，将其他像素赋值为0；2、THRESH_BINARY_INY：将所有大于thresh的像素赋值为0，将其他像素赋值为maxval；3、THRESH_TRUNC：截断，将所有大于thresh的像素赋值为thresh，其他像素值不变；4、THRESH_TOZERO：所有大于thresh的像素值保持不变，将其他像素赋值为0；5、THRESH_TOZERO_INV：所有大于thresh的像素值赋值为0，其他像素值保持不变.6、THRESH_OTSU:使用Otsu算法去寻找到最优的阈值7、THRESH_TRIANGLE：使用三角化方法寻找到最有的阈值*&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>【应用】：可用于区分图像的前景和背景（通常前景的像素值大于背景的像素值）；</p></blockquote><h2 id="形态学运算变换图像"><a href="#形态学运算变换图像" class="headerlink" title="形态学运算变换图像"></a>形态学运算变换图像</h2><p><strong>概念</strong></p><ul><li>形态学是一种滤波器，用结构元素探测图像中每个像素的操作过程称为形态学滤波器的应用过程；</li><li>结构元素是一堆像素的组合，原则上可以是任何形状，通常是正方形、圆形或菱形，中心点为原点（锚点）。<br> <strong>作用</strong></li><li>可用于强化或消除特殊形状</li></ul><p><img src="/pic/%E9%80%89%E5%8C%BA_043.png"></p><p><strong>腐蚀与膨胀</strong></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;腐蚀图像&#x2F;&#x2F;原理：在某个像素上应用结构元素时，结构元素的锚点与该像素对齐，腐蚀就是把当前像素替换成所定义像素集合中的最小像素值。void cv::erode  (       InputArray  src,           &#x2F;&#x2F;输入图像：灰度图像&amp;彩色图像    OutputArray     dst,       &#x2F;&#x2F;输出图像    InputArray  kernel,           &#x2F;&#x2F;结构元素，默认cv::Mat()，3x3的正方形    Point   anchor &#x3D; Point(-1,-1),  &#x2F;&#x2F;结构元素的锚点位置，默认为中心    int     iterations &#x3D; 1,         &#x2F;&#x2F;腐蚀次数    int     borderType &#x3D; BORDER_CONSTANT,  &#x2F;&#x2F;边界类型（像素外推的方法）    const Scalar &amp;  borderValue &#x3D; morphologyDefaultBorderValue()   &#x2F;&#x2F;连续边界的边界值)&#x2F;&#x2F;膨胀图像&#x2F;&#x2F;原理：把当前像素替换成所定义像素集合中的最大像素值。void cv::dilate (       InputArray  src,    OutputArray     dst,    InputArray  kernel,    Point   anchor &#x3D; Point(-1,-1),    int     iterations &#x3D; 1,    int     borderType &#x3D; BORDER_CONSTANT,    const Scalar &amp;  borderValue &#x3D; morphologyDefaultBorderValue() )       &#x2F;&#x2F;增加腐蚀&#x2F;膨胀次数或者使用更大的结构元素，都会增加腐蚀&#x2F;膨胀的效果。&#x2F;&#x2F;以腐蚀和膨胀操作作为基础，执行高级的形态变换void cv::morphologyEx   (       InputArray  src,    OutputArray     dst,    int     op,             &#x2F;&#x2F;形态学操作类型    InputArray  kernel,    Point   anchor &#x3D; Point(-1,-1),    int     iterations &#x3D; 1,    int     borderType &#x3D; BORDER_CONSTANT,         const Scalar &amp;  borderValue &#x3D; morphologyDefaultBorderValue() )   <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>形态学梯度运算提取图像边缘</strong></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;以腐蚀和膨胀操作作为基础，执行高级的形态变换void cv::morphologyEx   (       InputArray  src,    OutputArray     dst,    int     op,             &#x2F;&#x2F;形态学操作类型    InputArray  kernel,    Point   anchor &#x3D; Point(-1,-1),    int     iterations &#x3D; 1,    int     borderType &#x3D; BORDER_CONSTANT,         const Scalar &amp;  borderValue &#x3D; morphologyDefaultBorderValue() )   <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>图形分割</strong></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">CV_EXPORTS_W void watershed( InputArray image, InputOutputArray markers );&#x2F;&#x2F; cv::InputArray image：待分割的源图像；&#x2F;&#x2F; cv::InputOutputArray markers：标记图像；即这个参数用于存放函数调后的输出结果，需和源图片有一样的尺寸和类型。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><a href="https://blog.csdn.net/weixin_43863869/article/details/128534217">利用分水岭算法实现图像分割</a></p><h2 id="图像滤波"><a href="#图像滤波" class="headerlink" title="图像滤波"></a>图像滤波</h2><ul><li>概念：即选择性地提取图像中某些方面的内容，这些内容通常在特定的应用环境下传达了重要信息。</li><li>作用：滤波器是一种放大（也可以不改变）图像中某些频段，同时滤掉（或减弱）其他频段的算子，分为低通滤波器&amp;高通滤波器。</li><li>示例：去噪（噪声点）、重采样</li></ul><h3 id="频域分析"><a href="#频域分析" class="headerlink" title="频域分析"></a>频域分析</h3><p>描述图像的两种形式：</p><ul><li>频域：观察图像内容强度值（灰度值）变化的频率（蓝天 VS 杂货间），图像中精致的细节对应着高频；</li></ul><p><img src="/pic/%E9%80%89%E5%8C%BA_044.png"></p><ul><li>空域：观察图像内容灰度分布来描述图像特征（直方图）</li></ul><p><strong>频域分析</strong>：把图像分解成从低频到高频的频率成分。图像强度值变化慢的区域只包含低频率，强度值变化快的区域产生高频率。</p><p>二维图像的频率分为垂直频率和水平频率。</p><h3 id="低通滤波器"><a href="#低通滤波器" class="headerlink" title="低通滤波器"></a>低通滤波器</h3><p>目的：消除图像中的高频部分，减少图像变化的幅度（把前景变得光滑；把前景和背景之间的差异变小）。</p><p>常用方法：把每个像素的值替换成它周围像素的平均值，线性滤波。</p><p><strong>块滤波器（box filter）——&gt;卷积核（掩膜）</strong></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;典型示例一：均值滤波器void cv::blur   (       InputArray  src,                  &#x2F;&#x2F;输入图像    OutputArray     dst,              &#x2F;&#x2F;输出图像    Size    ksize,                    &#x2F;&#x2F;卷积核大小（值为系统默认指定？）    Point   anchor &#x3D; Point(-1,-1),     &#x2F;&#x2F;锚点位置    int     borderType &#x3D; BORDER_DEFAULT &#x2F;&#x2F;边界类型)   void cv::boxFilter  (       InputArray  src,    OutputArray     dst,    int     ddepth,    Size    ksize,    Point   anchor &#x3D; Point(-1,-1),    bool    normalize &#x3D; true,    int     borderType &#x3D; BORDER_DEFAULT )   void cv::filter2D   (       InputArray  src,    OutputArray     dst,    int     ddepth,    InputArray  kernel,                        &#x2F;&#x2F;卷积核值    Point   anchor &#x3D; Point(-1,-1),    double  delta &#x3D; 0,    int     borderType &#x3D; BORDER_DEFAULT )   &#x2F;&#x2F;典型示例二：高斯滤波器void cv::GaussianBlur   (       InputArray  src,    OutputArray     dst,    Size    ksize,                   &#x2F;&#x2F;滤波器尺寸,必须为奇数，否则会引发错误    double  sigmaX,                  &#x2F;&#x2F;控制高斯曲线水平方向形状的参数    double  sigmaY &#x3D; 0,              &#x2F;&#x2F;控制高斯曲线垂直方向形状的参数    int     borderType &#x3D; BORDER_DEFAULT     )  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>图像降采样</strong></p><ul><li>降低图像精度的过程称为缩减像素采样（downsampling）；</li><li>提升图像精度的过程称为提升像素采样（upsampling）</li></ul><p>难点：重采样的过程需要尽可能地保持图像质量</p><p><strong>中值滤波器</strong></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;原理：非线性滤波，把当前像素和它的邻域组成一个集合，然后计算出这个集合的中间值，以此作为当前像素的值（用邻域内集合的中位数代替当前像素值）void cv::medianBlur (       InputArray  src,    OutputArray     dst,    int     ksize                    &#x2F;&#x2F;注意这里的ksize类型是 int类型)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="高通滤波器"><a href="#高通滤波器" class="headerlink" title="高通滤波器"></a>高通滤波器</h3><p><strong>定向滤波器（边缘检测）</strong></p><ul><li>二维图像分为水平方向和垂直方向；</li><li>比较经典的卷积核称为算子</li></ul><p><img src="/pic/%E9%80%89%E5%8C%BA_045.png"></p><p><img src="/pic/%E9%80%89%E5%8C%BA_046.png"></p><blockquote><p>Q:如何辨别x方向和y方向的滤波？（分别沿x&#x2F;y方向去找灰度值发生急剧变化的边缘处）</p></blockquote><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;Sobel滤波器：只对垂直或水平方向的图像频率起作用void cv::Sobel  (       InputArray  src,    OutputArray     dst,    int     ddepth,             &#x2F;&#x2F;位深，-1代表输出图像和源图像的位深相同    int     dx,                 &#x2F;&#x2F;x方向的微分，几阶导数    int     dy,                 &#x2F;&#x2F;y方向的微分，几阶导数    int     ksize &#x3D; 3,          &#x2F;&#x2F;sobel内核尺寸，只能为 1,3,5或7    double  scale &#x3D; 1,    double  delta &#x3D; 0,    int     borderType &#x3D; BORDER_DEFAULT )   &#x2F;&#x2F;Schar滤波器void cv::Scharr (       InputArray  src,    OutputArray     dst,    int     ddepth,           &#x2F;&#x2F;注意，此处位深最好选用CV_16S,否则会丢失很多信息    int     dx,    int     dy,    double  scale &#x3D; 1,    double  delta &#x3D; 0,    int     borderType &#x3D; BORDER_DEFAULT )      &#x2F;&#x2F;Laplacian算子    void cv::Laplacian  (       InputArray  src,    OutputArray     dst,    int     ddepth,    int     ksize &#x3D; 1,    double  scale &#x3D; 1,    double  delta &#x3D; 0,    int     borderType &#x3D; BORDER_DEFAULT )       <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Canny边缘检测算子"><a href="#Canny边缘检测算子" class="headerlink" title="Canny边缘检测算子"></a>Canny边缘检测算子</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;Canny边缘检测算法void cv::Canny  (       InputArray  image,           &#x2F;&#x2F;8位的输入图像    OutputArray     edges,       &#x2F;&#x2F;输出图像，一般是二值图像    double  threshold1,          &#x2F;&#x2F;低阈值，常取高阈值的1&#x2F;2或1&#x2F;3    double  threshold2,          &#x2F;&#x2F;高阈值    int     apertureSize &#x3D; 3,    &#x2F;&#x2F;sobel算子的size，通常取值3    bool    L2gradient &#x3D; false   &#x2F;&#x2F;选择true表示用L2归一化，选择false表示用L1来归一化)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Opencv </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Opencv </tag>
            
            <tag> 直方图 </tag>
            
            <tag> 腐蚀膨胀 </tag>
            
            <tag> 图像滤波 </tag>
            
            <tag> Canny </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Opencv系列（一）</title>
      <link href="/2023/04/01/opencv/"/>
      <url>/2023/04/01/opencv/</url>
      
        <content type="html"><![CDATA[<h1 id="Opencv"><a href="#Opencv" class="headerlink" title="Opencv"></a>Opencv</h1><p><strong>main modules</strong></p><ul><li><p>core</p><p> 定义基本数据结构的紧凑模块，包括稠密的多维数组 Mat 和所有其他模块使用的基本功能。</p></li><li><p>imgproc</p><p> 一个图像处理模块，包括线性和非线性图像滤波、几何图像变换（调整大小、仿射和透视变换、通用的基于表的重映射）、色彩空间转换、直方图等。</p></li><li><p>imgcodecs</p><p> 图像文件的读取和写入</p></li><li><p>videoio</p><p> 视频输入和输出</p></li><li><p>highgui</p><p> GUI界面</p></li><li><p>calib3d</p><p> 相机标定和三维重建</p></li><li><p>features2d</p><p> 2d特征的检测，描述，匹配以及在图像上绘制2d特征点和匹配对</p></li><li><p>objdetect</p><p> 用于目标检测的基于Haar 特征的级联分类器  </p></li><li><p>dnn</p><p> 用于构建深度神经网络，主要是测试网络的输出，不支持网络训练</p></li><li><p>ml</p><p> 一组用于统计分类、回归和数据聚类的类和函数。</p><ul><li>flann<br>  FLANN库的opencv接口（功能不完整）</li></ul></li><li><p>photo</p><p> 照片处理算法，包括修补，去噪，HDR成像等</p></li><li><p>stitching</p><p> 图像拼接</p></li><li><p>gapi</p><p> OpenCV Graph API（或 G-API）是一个新的 OpenCV 模块，旨在使常规图像处理快速且便携。这两个目标是通过引入新的基于图的执行模型来实现的</p></li></ul><p><strong>contrib modules</strong></p><ul><li><p>alphamat</p><p> 从背景图像中提取具有软边界的前景</p></li><li><p>aruco</p><p> ArUco 标记是二进制方形基准标记，可用于相机姿态估计。他们的主要好处是他们的检测是鲁棒、快速和简单的。</p><p> aruco 模块包括这些类型的标记的检测以及使用它们进行姿势估计和相机校准的工具。 </p></li><li><p>bgsegm</p><p> 背景分割</p></li><li><p>bioinspired</p><p> 视网膜模型及其在图像处理中的应用</p></li><li><p>ccalib</p><p> 多相机和广角相机标定</p></li><li><p>cnn_3dobj</p><p> 用于3D物体分类和位姿估计的卷积神经网络 </p></li><li><p>cvv</p><p> 应用于计算机视觉类应用的交互式Debug </p></li><li><p>dnn_objdetect</p><p> 使用卷积神经网络进行目标检测</p></li><li><p>dnn_superres</p><p> 使用卷积神经网络进行图像放大（提高分辨率）</p></li><li><p>face</p><p>  人脸识别的相关算法</p></li><li><p>fuzzy</p><p> 模糊数学理论在图像处理中的应用，主要是F变换 </p></li><li><p>hdf</p><p> hdf5文件的输入和输出</p></li><li><p>Julia</p><p> OpenCV的Julia语言封装</p></li><li><p>line_descriptor</p><p> 从图像中检测直线</p></li><li><p>mcc</p><p> 图像色彩校正</p></li><li><p>phase_unwrapping</p><p> 二维相位展开</p></li><li><p>sfm</p><p> 运动结构恢复</p></li><li><p>stereo</p><p> 稠密立体匹配</p></li><li><p>structured_light</p><p> 结构光反射图案的解析</p></li><li><p>Text</p><p> Tesseract文字识别框架</p></li><li><p>tracking</p><p> 图像中的物体追踪</p></li><li><p>viz</p><p> 可视化窗口（类似Qt）</p></li><li><p>ximgproc</p><p> 拓展图像处理模块。包含结构森林，变化域滤波器，导向滤波，自适应流行滤波器，联合双边滤波器和超像素。</p></li><li><p>xphoto</p><p> 白平衡调整</p></li></ul><h1 id="Opencv如何对像素进行操作"><a href="#Opencv如何对像素进行操作" class="headerlink" title="Opencv如何对像素进行操作"></a>Opencv如何对像素进行操作</h1><h2 id="取"><a href="#取" class="headerlink" title="取"></a>取</h2><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">Mat cv::imread  (   const String &amp;  filename,                    int     flags &#x3D; IMREAD_COLOR                 )   <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>filename （必须的）：需要读取的图像名，你也可以写成读取的路径：绝对路劲和相对路径都可</p><p>flag （可选）：flag时读取图像的格式。<br>如果你没有flag选项就按照原始的图像格式，如果有flag选项就按照flag格式读取<br>flag可以是数字，也可以是具体的类型（枚举)</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">enum ImreadModes &#123;       IMREAD_UNCHANGED            &#x3D; -1, &#x2F;&#x2F;!&lt; If set, return the loaded image as is (with alpha channel, otherwise it gets cropped).       IMREAD_GRAYSCALE            &#x3D; 0,  &#x2F;&#x2F;!&lt; If set, always convert image to the single channel grayscale image.       IMREAD_COLOR                &#x3D; 1,  &#x2F;&#x2F;!&lt; If set, always convert image to the 3 channel BGR color image.       IMREAD_ANYDEPTH             &#x3D; 2,  &#x2F;&#x2F;!&lt; If set, return 16-bit&#x2F;32-bit image when the input has the corresponding depth, otherwise convert it to 8-bit.       IMREAD_ANYCOLOR             &#x3D; 4,  &#x2F;&#x2F;!&lt; If set, the image is read in any possible color format.       IMREAD_LOAD_GDAL            &#x3D; 8,  &#x2F;&#x2F;!&lt; If set, use the gdal driver for loading the image.       IMREAD_REDUCED_GRAYSCALE_2  &#x3D; 16, &#x2F;&#x2F;!&lt; If set, always convert image to the single channel grayscale image and the image size reduced 1&#x2F;2.       IMREAD_REDUCED_COLOR_2      &#x3D; 17, &#x2F;&#x2F;!&lt; If set, always convert image to the 3 channel BGR color image and the image size reduced 1&#x2F;2.       IMREAD_REDUCED_GRAYSCALE_4  &#x3D; 32, &#x2F;&#x2F;!&lt; If set, always convert image to the single channel grayscale image and the image size reduced 1&#x2F;4.       IMREAD_REDUCED_COLOR_4      &#x3D; 33, &#x2F;&#x2F;!&lt; If set, always convert image to the 3 channel BGR color image and the image size reduced 1&#x2F;4.       IMREAD_REDUCED_GRAYSCALE_8  &#x3D; 64, &#x2F;&#x2F;!&lt; If set, always convert image to the single channel grayscale image and the image size reduced 1&#x2F;8.       IMREAD_REDUCED_COLOR_8      &#x3D; 65, &#x2F;&#x2F;!&lt; If set, always convert image to the 3 channel BGR color image and the image size reduced 1&#x2F;8.       IMREAD_IGNORE_ORIENTATION   &#x3D; 128 &#x2F;&#x2F;!&lt; If set, do not rotate the image according to EXIF&#39;s orientation flag.     &#125;;     <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="存"><a href="#存" class="headerlink" title="存"></a>存</h2><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">bool cv::imwrite    (   const String &amp;  filename,                        InputArray  img,                        const std::vector&lt; int &gt; &amp;params&#x3D;std::vector&lt; int &gt;()                     )   <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>filename （必须）同上<br>img  （必须）表示需要保存的Mat类型的图像数据<br>通常，使用此功能只能保存 8 位单通道或 3 通道（具有“BGR”通道顺序）图像，除去一些特殊情况。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">enum ImwriteFlags &#123;       IMWRITE_JPEG_QUALITY        &#x3D; 1,  &#x2F;&#x2F;!&lt; For JPEG, it can be a quality from 0 to 100 (the higher is the better). Default value is 95.       IMWRITE_JPEG_PROGRESSIVE    &#x3D; 2,  &#x2F;&#x2F;!&lt; Enable JPEG features, 0 or 1, default is False.       IMWRITE_JPEG_OPTIMIZE       &#x3D; 3,  &#x2F;&#x2F;!&lt; Enable JPEG features, 0 or 1, default is False.       IMWRITE_JPEG_RST_INTERVAL   &#x3D; 4,  &#x2F;&#x2F;!&lt; JPEG restart interval, 0 - 65535, default is 0 - no restart.       IMWRITE_JPEG_LUMA_QUALITY   &#x3D; 5,  &#x2F;&#x2F;!&lt; Separate luma quality level, 0 - 100, default is 0 - don&#39;t use.       IMWRITE_JPEG_CHROMA_QUALITY &#x3D; 6,  &#x2F;&#x2F;!&lt; Separate chroma quality level, 0 - 100, default is 0 - don&#39;t use.       IMWRITE_PNG_COMPRESSION     &#x3D; 16, &#x2F;&#x2F;!&lt; For PNG, it can be the compression level from 0 to 9. A higher value means a smaller size and longer compression time. If specified, strategy is changed to IMWRITE_PNG_STRATEGY_DEFAULT (Z_DEFAULT_STRATEGY). Default value is 1 (best speed setting).       IMWRITE_PNG_STRATEGY        &#x3D; 17, &#x2F;&#x2F;!&lt; One of cv::ImwritePNGFlags, default is IMWRITE_PNG_STRATEGY_RLE.       IMWRITE_PNG_BILEVEL         &#x3D; 18, &#x2F;&#x2F;!&lt; Binary level PNG, 0 or 1, default is 0.       IMWRITE_PXM_BINARY          &#x3D; 32, &#x2F;&#x2F;!&lt; For PPM, PGM, or PBM, it can be a binary format flag, 0 or 1. Default value is 1.       IMWRITE_EXR_TYPE            &#x3D; (3 &lt;&lt; 4) + 0, &#x2F;* 48 *&#x2F; &#x2F;&#x2F;!&lt; override EXR storage type (FLOAT (FP32) is default)       IMWRITE_WEBP_QUALITY        &#x3D; 64, &#x2F;&#x2F;!&lt; For WEBP, it can be a quality from 1 to 100 (the higher is the better). By default (without any parameter) and for quality above 100 the lossless compression is used.       IMWRITE_PAM_TUPLETYPE       &#x3D; 128,&#x2F;&#x2F;!&lt; For PAM, sets the TUPLETYPE field to the corresponding string value that is defined for the format       IMWRITE_TIFF_RESUNIT &#x3D; 256,&#x2F;&#x2F;!&lt; For TIFF, use to specify which DPI resolution unit to set; see libtiff documentation for valid values       IMWRITE_TIFF_XDPI &#x3D; 257,&#x2F;&#x2F;!&lt; For TIFF, use to specify the X direction DPI       IMWRITE_TIFF_YDPI &#x3D; 258 &#x2F;&#x2F;!&lt; For TIFF, use to specify the Y direction DPI     &#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="ROI区域"><a href="#ROI区域" class="headerlink" title="ROI区域"></a>ROI区域</h2><blockquote><p>定义<br>有事需要让一个处理函数只在图像的某个部分起作用，所以需要定义图像的子区域，也就是ROI区域（region of interest）感兴趣区域</p></blockquote><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int  main()&#123;cv::Mat image&#x3D; cv::imread(&quot;3.png&quot;);cv::Mat logo&#x3D; cv::imread(&quot;2.jpg&quot;);cv::Mat imageROI(image,                                    cv::Rect(0,                                    0,                                    logo.cols,                                    logo.rows));imshow(&quot;1&quot;,imageROI);&#x2F;&#x2F;将logo替换image中的感兴区域imageROIlogo.copyTo(imageROI);imshow(&quot;2&quot;,logo);imshow(&quot;3&quot;,image);cv::waitKey(0);return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>扩展：除了使用起点和终点位置，还可以通过列数和行数实现ROI区域定义：</p></blockquote><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">cv:: Mat imageROI &#x3D; image(cv::Range(0,logo.rows),                                  cv::Range(0,logo.cols));<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="指针遍历"><a href="#指针遍历" class="headerlink" title="指针遍历"></a>指针遍历</h2><p>像素遍历就是将图像的所有像素都访问一次。由于图像像素数量非常庞大，高效遍历就十分必要</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int nl&#x3D; image.rows; &#x2F;&#x2F; 行数 &#x2F;&#x2F; 每行的元素数量 int nc&#x3D; image.cols * image.channels();  for (int j&#x3D;0; j&lt;nl; j++) &#123;  &#x2F;&#x2F; 取得行 j 的地址,这里以uchar图像类型作为例子 uchar* data&#x3D; image.ptr&lt;uchar&gt;(j);  for (int i&#x3D;0; i&lt;nc; i++) &#123; &#x2F;&#x2F; 处理每个像素 data[i] &#125; &#x2F;&#x2F; 一行结束 &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>例子：减色算法，对每个像素做减色，对于8为无符号字符类型的彩色图有256x256x256中颜色，减色就是减色颜色的种类</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;*减色算法：假设 N 是减色因子，将图像中每个像素的值除以 N（这里假定使用整数除法，不保留余数）。然后将结果乘以 N，得到 N 的倍数，并且刚好不超过原始像素 值。加上 N &#x2F; 2，就得到相邻的 N 倍数之间的中间值。对所有 8 位通道值重复这个过程，就会得到  (256 &#x2F; N) × (256 &#x2F; N) × (256 &#x2F; N)种可能的颜色值*&#x2F;void colorReduce(cv::Mat image, int div &#x3D;64)&#123;    int nl &#x3D;image.rows;    int nc &#x3D;image.cols;    for(int j&#x3D;0;j&lt;nl;j++)&#123;        uchar* data&#x3D;image.ptr&lt;uchar&gt;(j);        for(int i&#x3D;0;i&lt;nc;i++)&#123;            data[i]&#x3D; data[i]&#x2F;div*div+div&#x2F;2;                    &#125;    &#125;&#125;int  main()&#123;    cv::Mat image&#x3D;cv::imread(&quot;1.jpg&quot;);    colorReduce(image);    cv::imshow(&quot;1&quot;,image);    cv::waitKey();    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="迭代器遍历"><a href="#迭代器遍历" class="headerlink" title="迭代器遍历"></a>迭代器遍历</h2><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;创建迭代器bagin和end，注意要给出图像的数据类型，此处以cv::Vec3b为例&#x2F;&#x2F;在opencv中cv::Vec3b向量包含三个无符号字符类型的数据，可以用于描述彩色图的三通道。cv::Mat_&lt;cv::Vec3b&gt;::iterator it&#x3D; image.begin&lt;cv::Vec3b&gt;(); cv::Mat_&lt;cv::Vec3b&gt;::iterator itend&#x3D; image.end&lt;cv::Vec3b&gt;();  &#x2F;&#x2F; 扫描全部像素 for ( ; it!&#x3D; itend; ++it) &#123; &#x2F;&#x2F;处理每个像素 (*it)[0] (*it)[1] (*it)[2] &#125; &#x2F;&#x2F;或者while (it!&#x3D; itend) &#123;  &#x2F;&#x2F; 处理每个像素 ---------------------  ... &#x2F;&#x2F; 像素处理结束 ---------------------  ++it; &#125; <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="Opencv点检测"><a href="#Opencv点检测" class="headerlink" title="Opencv点检测"></a>Opencv点检测</h1><h2 id="Harris角点检测"><a href="#Harris角点检测" class="headerlink" title="Harris角点检测"></a>Harris角点检测</h2><h3 id="角点定义"><a href="#角点定义" class="headerlink" title="角点定义"></a>角点定义</h3><p>角点是图像中某些属性较为突出的像素点，例如像素值最大或者最小的点、线段的顶点、孤立的边缘点等，图中圆圈包围的线段的拐点就是一些常见的角点。常用的角点有以下几种。  </p><ul><li>灰度梯度的最大值对应的像素点；  </li><li>两条直线或者曲线的交点；  </li><li>一阶梯度的导数最大值和梯度方向变化率最大的像素点；  </li><li>一阶导数值最大，但是二阶导数值为0的像素点；</li></ul><h3 id="Harris算法原理"><a href="#Harris算法原理" class="headerlink" title="Harris算法原理"></a>Harris算法原理</h3><p>Harris角点是最经典的角点之一，其从像素值变化度对角点进行定义，像素值的局部最大峰值即为Harris角点。Harris角点的检测过程如图9-3所示，首先以某个像素为中心构建一个矩形滑动窗口，滑动窗口覆盖图像像素值通过线性叠加得到得到滑动窗口所有像素值的衡量系数，该系数与滑动窗口范围内的像素值成正比，当滑动窗口范围内像素值整体变大时，该衡量系数也变大。在图像中以每个像素为中心向各个方向移动滑动窗口，当滑动窗口无论向哪个方向移动像素值衡量系数都缩小时，滑动窗口中心点对应的像素点即为Haris角点</p><p><img src="/pic/%E9%80%89%E5%8C%BA_032.png"></p><p>角点检测最原始的想法就是取某个像素的一个邻域窗口，当这个窗口在各个方向上进行小范围移动时，观察窗口内平均的像素灰度值的变化（即E(u,v)，Window-averaged change of intensity）。从上图可知，我们可以将一幅图像大致分为三个区域（‘flat’，‘edge’，‘corner’），这三个区域变化是不一样的。</p><p><img src="/pic/%E9%80%89%E5%8C%BA_035.png"></p><p>其中：  </p><ul><li>u、v是窗口在水平，竖直方向的偏移；  </li><li>w(x,y)表示滑动窗口权重函数，可以是常数，也可以是高斯函数；</li></ul><p><img src="/pic/%E9%80%89%E5%8C%BA_034.png"></p><p>图中蓝线圈出的地方我们称之为Harris角点的梯度协方差矩阵，记为M。其中，Ix和Iy分别为X方向和Y方向的梯度。  由于E(x,y)取值与M相关，进一步对其进行简化，定义Harris角点评价系数R为：</p><blockquote><p>R&#x3D;det(M)-k(tr(M))^2</p></blockquote><p>其中k为常值权重系数，det(M)&#x3D;λ1λ2,tr(M)&#x3D;λ1+λ2,λ1和λ2是梯度协方差矩阵M的特征向量，将特征向量代入得:</p><blockquote><p>R&#x3D;λ1λ2-k(λ1+λ2)^2</p></blockquote><p>当R较大时，说明两个特征向量较相似或者接近，则该点为角点；当R&lt;0时，说明两个特征向量相差较大，则该点位于直线上；当|R|较小，说明两个特征值较小，则该点位于平面。</p><h3 id="Opencv实现"><a href="#Opencv实现" class="headerlink" title="Opencv实现"></a>Opencv实现</h3><p><strong>cornerHarris()——计算角点Harris评价系数R</strong></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void cv::cornerHarris( InputArray src, OutputArray dst, int blockSize, int ksize, double k, int borderType &#x3D; BORDER_DEFAULT)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>src:待检测Harris角点的输入图像，图像必须是CV_8U或者CV_32F的单通道灰度图像；</li><li>dst:存放Harris评价系数R的矩阵，数据类型为CV_32F的单通道图像，与输入图像具有相同的尺寸</li><li>blockSize:邻域大小（窗口大小），通常取2；</li><li>ksize：Sobel算子的半径，用于得到图像梯度信息，该参数需要是奇数，多使用3或者5；</li><li>k:计算Harris评价系数R的权重系数，一般取值为0.02~0.04;</li><li>borderType：像素外推算法标志，这里使用默认。</li></ul><p><strong>drawKeypoints()——一次性绘制所有的角点（关键词）</strong></p><blockquote><p>绘制关键点</p></blockquote><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void drawKeypoints(  InputArray image,  const std::vector&lt;KeyPoint&gt;&amp; keypoints, InputOutputArray outImage, const Scalar&amp; color&#x3D;Scalar::all(-1), int flags&#x3D;DrawMatchesFlags::DEFAULT )   &#x2F;&#x2F;KeyPoint类数据 class KeyPoint&#123; float angle      &#x2F;&#x2F;关键点的角度 int class_id     &#x2F;&#x2F;关键点的分类号 int octave       &#x2F;&#x2F;特征点来源（“金字塔”） Point2f pt       &#x2F;&#x2F;关键点坐标 float response   &#x2F;&#x2F;最强关键点的响应 float size       &#x2F;&#x2F;关键点邻域的直径 <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>image:绘制关键点的原图像，图像可以是单通道的灰度图像和三通道的彩色图像；</li><li>keypoints:来自原图像中的关键点向量，vector向量中存放着表示关键点的KeyPoint类型的数据；</li><li>outImage：绘制关键点后的输出图像；</li><li>color：关键点空心圆的颜色，默认使用随机颜色绘制空心圆；</li><li>flag:绘制功能选择标志，其实就是设置特征点的那些信息需要绘制，那些不需要绘制，有以下几种模式可选：</li></ul><table><thead><tr><th align="center">标志参数</th><th align="center">简记</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">DEFAULT</td><td align="center">0</td><td align="center">只绘制特征点的坐标点,显示在图像上就是一个个小圆点,每个小圆点的圆心坐标都是特征点的坐标。</td></tr><tr><td align="center">DRAW_OVER_OUTIMG</td><td align="center">1</td><td align="center">函数不创建输出的图像,而是直接在输出图像变量空间绘制,要求本身输出图像变量就是一个初始化好了的,size与type都是已经初始化好的变量</td></tr><tr><td align="center">NOT_DRAW_SINGLE_POINTS</td><td align="center">2</td><td align="center">单点的特征点不被绘制</td></tr><tr><td align="center">DRAW_RICH_KEYPOINTS</td><td align="center">4</td><td align="center">绘制特征点的时候绘制的是一个个带有方向的圆,这种方法同时显示图像的坐标,size，和方向,是最能显示特征的一种绘制方式</td></tr></tbody></table><blockquote><p>Harris 算法实现步骤：<br>（1）计算图像在两个方向上的梯度<br>（2）计算两个方向梯度乘积<br>（3）使用高斯函数进行加权平均，生成矩阵元素和<br>（4）计算每个像素Harris响应值，并对小于某一个阈值的像素置0<br>（5）在阈值的邻域内进行非最大值抑制，局部最大值即为Harris角点Harris算法优劣：  </p></blockquote><blockquote><p>（1）优点：计算简单，提取的特征点均匀且合理稳定（对图像旋转、亮度变化、噪声影响和视点变换不敏感）；<br>（2）缺点：a.对尺度很敏感，不具有尺度不变性；b.提取的角点精度是像素级的；c.需要设计对应的描述子和匹配算法；</p></blockquote><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int  main()&#123;    cv::Mat image&#x3D;cv::imread(&quot;1.png&quot;);    cv::Mat grayImage;    cv::cvtColor(image,grayImage,CV_BGR2GRAY);    cv::Mat dstImage;    cv::cornerHarris(grayImage,dstImage,2,3,0.01);    cv::imshow(&quot;直接显示&quot;,dstImage);    cv::Mat thredImage;threshold(dstImage, thredImage, 0.0001, 255, CV_THRESH_BINARY);imshow(&quot;【阀值后显示】&quot;, thredImage);    cv::waitKey();    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>绘制匹配点</p></blockquote><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void cv::drawMatches (InputArray img1,const std::vector&lt; KeyPoint &gt; &amp; keypoints1,InputArray img2,const std::vector&lt; KeyPoint &gt; &amp; keypoints2,const std::vector&lt; DMatch &gt; &amp; matches1to2,InputOutputArray outImg,const Scalar &amp; matchColor &#x3D; Scalar::all(-1),const Scalar &amp; singlePointColor &#x3D; Scalar::all(-1),const std::vector&lt; char &gt; &amp; matchesMask &#x3D; std::vector&lt; char &gt;(),DrawMatchesFlags flags &#x3D; DrawMatchesFlags::DEFAULT)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>img1:第一个源图像，</li><li>keypoints1:第一个源图像的关键点，</li><li>img2:第二个源图像，</li><li>keypoints2:第二个源图像的关键点，</li><li>matches1to2:从第一张图像匹配到第二张图像，</li><li>outimg: 输出图像。它的内容取决于定义在输出图像中绘制的内容的标志值，</li><li>matchColor:匹配的颜色（线和连接的关键点），</li><li>singlePointColor:单个关键点（圆圈）的颜色，表示关键点不匹配，</li><li>matchesMask:确定绘制哪些匹配项的掩码。如果掩码为空，则绘制所有匹配项。</li><li>flags:标志设置绘图功能</li></ul><h2 id="SIFT特征点检测"><a href="#SIFT特征点检测" class="headerlink" title="SIFT特征点检测"></a>SIFT特征点检测</h2><h3 id="SIFT综述"><a href="#SIFT综述" class="headerlink" title="SIFT综述"></a>SIFT综述</h3><p>尺度不变特征转换(SIFT)是一种电脑视觉的算法用来侦测与描述影像中的局部性特征，它在空间尺度中寻找极值点，并提取出其位置、尺度、旋转不变量，此算法由 David Lowe在1999年所发表，2004年完善总结。</p><p>Lowe将SIFT算法分解为如下四步：  </p><ul><li>尺度空间极值检测：搜索所有尺度上的图像位置。通过高斯微分函数来识别潜在的对于尺度和旋转不变的兴趣点。  </li><li>关键点定位：在每个候选的位置上，通过一个拟合精细的模型来确定位置和尺度。关键点的选择依据于它们的稳定程度。  </li><li>方向确定：基于图像局部的梯度方向，分配给每个关键点位置一个或多个方向。所有后面的对图像数据的操作都相对于关键点的方向、尺度和位置进行变换，从而提供对于这些变换的不变性。  </li><li>关键点描述：在每个关键点周围的邻域内，在选定的尺度上测量图像局部的梯度。这些梯度被变换成一种表示，这种表示允许比较大的局部形状的变形和光照变化。</li></ul><h3 id="SIFT算法的OpenCV实现"><a href="#SIFT算法的OpenCV实现" class="headerlink" title="SIFT算法的OpenCV实现"></a>SIFT算法的OpenCV实现</h3><p>OpenCV中的SIFT函数主要有两个接口。</p><p>构造函数：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">SIFT::SIFT(int nfeatures&#x3D;0, int nOctaveLayers&#x3D;3, double contrastThreshold&#x3D;0.04, double edgeThreshold&#x3D;10, double sigma&#x3D;1.6) <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li>nfeatures：特征点数目（算法对检测出的特征点排名，返回最好的nfeatures个特征点）。</li><li>nOctaveLayers：金字塔中每组的层数（算法中会自己计算这个值，后面会介绍）。</li><li>contrastThreshold：过滤掉较差的特征点的对阈值。contrastThreshold越大，返回的特征点越少。</li><li>edgeThreshold：过滤掉边缘效应的阈值。edgeThreshold越大，特征点越多（被多滤掉的越少）。</li><li>sigma：金字塔第0层图像高斯滤波系数，也就是σ。</li></ul><p>重载操作符：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void SIFT::operator()(InputArray img, InputArray mask, vector&lt;KeyPoint&gt;&amp; keypoints, OutputArray descriptors, bool useProvidedKeypoints&#x3D;false) <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li>img：8bit灰度图像 mask：图像检测区域（可选）</li><li>keypoints：特征向量矩阵</li><li>descipotors：特征点描述的输出向量（如果不需要输出，需要传cv::noArray()）。</li><li>useProvidedKeypoints：是否进行特征点检测。ture，则检测特征点；false，只计算图像特征描述。</li></ul><h3 id="SURF特征"><a href="#SURF特征" class="headerlink" title="SURF特征"></a>SURF特征</h3><p>SURF（Speeded Up Robust Features）是对SIFT的一种改进，主要特点是快速。SURF与SIFT主要有以下几点不同处理：</p><blockquote><p>1、SIFT在构造DOG金字塔以及求DOG局部空间极值比较耗时，SURF的改进是使用Hessian矩阵变换图像，极值的检测只需计算Hessian矩阵行列式，作为进一步优化，使用一个简单的方程可以求出Hessian行列式近似值，使用盒状模糊滤波（box  blur）求高斯模糊近似值。<br>2、 SURF不使用降采样，通过保持图像大小不变，但改变盒状滤波器的大小来构建尺度金字塔。<br>3、在计算关键点主方向以及关键点周边像素方向的方法上，SURF不使用直方图统计，而是使用哈尔(haar)小波转换。SIFT的KPD达到128维，导致KPD的比较耗时，SURF使用哈尔(haar)小波转换得到的方向，让SURF的KPD降到64维，减少了一半，提高了匹配速度</p></blockquote><h2 id="ORB特征"><a href="#ORB特征" class="headerlink" title="ORB特征"></a>ORB特征</h2><p>ORB特征由关键点和描述子两部分组成，关键点称为“Oriented FAST”，是一种改进的FAST 角点。它的描述子称为BRIEF(Binary Robust Independent Elementary Feature)。</p><p>提取 ORB 特征分为如下两个步骤：  </p><ul><li>FAST 角点提取：找出图像中的“角点”。相较于原始的 FAST，ORB 中计算了特征点的主方向，为BRIEF 描述子增加了旋转不变特性。  </li><li>BRIEF 描述子的计算：对前一步提取出特征点的周围图像区域进行描述。ORB 对 BRIEF 进行了改进，主要是在BRIEF 中使用了先前计算的方向信息。</li></ul><h3 id="FAST关键点"><a href="#FAST关键点" class="headerlink" title="FAST关键点"></a>FAST关键点</h3><p>FAST 是一种角点，主要检测局部像素灰度变化明显的地方，以速度快著称。它的思想是：如果一个像素与邻域的像素差别较大（过亮或过暗），那么它可能是角点。检测步骤如下：</p><ul><li>在图像中选取像素 p，假设它的亮度为Ip。</li><li>设置一个阈值 T（比如，Ip的20%）。</li><li>以像素 p 为中心，选取半径为3的圆上的16个像素点。</li><li>假如选取的圆上有连续的 N 个点的亮度大于 Ip+T 或小于 Ip−T，那么像素p 可以被认为是特征点（N通常取12，即为 FAST-12。其他常用的N取值为9和11，它们分别被称为FAST-9和FAST-11）。</li><li>循环以上四步，对每一个像素执行相同的操作。</li></ul><p>在FAST-12算法中，可以进行预测试操作，以快速地排除绝大多数不是角点的像素。</p><blockquote><p>具体操作为，对于每个像素，直接检测邻域圆上的第 1, 5, 9, 13 个像素的亮度。只有当这 4个像素中有 3 个同时大于 Ip+T或小于 Ip−T 时，当前像素才有可能是一个角点，否则应该直接排除。这大大加速了角点检测。</p></blockquote><p>还需要用非极大值抑制(Non-maximal suppression)，在一定区域内仅保留响应极大值的角点，避免角点集中的问题。  </p><p><img src="/pic/%E9%80%89%E5%8C%BA_037.png" alt="FAST特征点"></p><p>FAST特征点的计算仅仅是比较像素间亮度的差异，所以速度非常快。它的缺点是重复性不强，分布不均匀，不具有方向信息。同时，由于它固定取半径为3的圆，存在尺度问题：远处看着像是角点的地方，接近后看可能就不是角点了。</p><blockquote><p>针对 FAST 角点不具有方向性和尺度的弱点，ORB添加了尺度和旋转的描述。尺度不变性由构建图像金字塔解决，在金字塔的每一层上检测角点。特征的旋转是由灰度质心法(Intensity Centroid)实现。</p></blockquote><p><img src="/pic/%E9%80%89%E5%8C%BA_038.png" alt="使用金字塔可以匹配不同缩放倍率下的图像"></p><p>图像金字塔如上图，金字塔底层是原始图像，每往上一层，就对图像进行一个固定倍率的缩放，这样就有了不同分辨率的图像。较小的图像可以看成是远处看过来的场景。在特征匹配算法中，我们可以匹配不同层上的图像，从而实现尺度不变性。例如，如果相机在后退，那么我们应该能够在上一个图像金字塔的上层和下一个图像的下层中找到匹配。</p><p><img src="/pic/%E9%80%89%E5%8C%BA_039.png"></p><p>通过以上方法，FAST 角点便具有了尺度与旋转的描述，从而大大提升了其在不同图像之间表述的鲁棒性。所以在 ORB中，把这种改进后的 FAST 称为 Oriented FAST。</p><h3 id="BRIEF描述子"><a href="#BRIEF描述子" class="headerlink" title="BRIEF描述子"></a>BRIEF描述子</h3><p>在提取 Oriented FAST 关键点后，对每个点计算其描述子，ORB 使用改进的BRIEF特征描述。BRIEF 是一种二进制描述子，其描述向量由许多个 0 和 1 组成，这里的 0 和 1 编码了关键点附近两个随机像素（比如p和q）的大小关系：如果p 比 q 大，则取 1，反之就取 0。如果我们取了 128个这样的 p, q，最后就得到 128 维由 0、1 组成的向量。关于一对随机点的选择方法，ORB论文原作者测试了以下5种方法，发现方法（2）比较好：</p><p><img src="/pic/%E9%80%89%E5%8C%BA_040.png"></p><p>原始的 BRIEF 描述子不具有旋转不变性，因此在图像发生旋转时容易丢失。而 ORB 在 FAST 特征点提取阶段计算了关键点的方向，所以可以利用方向信息，计算了旋转之后的“Steer BRIEF”特征使 ORB 的描述子具有较好的旋转不变性。</p><p><strong>ORB类定义</strong></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">CV_WRAP static Ptr&lt;ORB&gt; create(int nfeatures&#x3D;500, float scaleFactor&#x3D;1.2f, int nlevels&#x3D;8, int edgeThreshold&#x3D;31,    int firstLevel&#x3D;0, int WTA_K&#x3D;2, int scoreType&#x3D;ORB::HARRIS_SCORE, int patchSize&#x3D;31, int fastThreshold&#x3D;20);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>其中：</p><ul><li>nfeatures:需要的特征点总数；</li><li>scaleFactor:尺度因子；</li><li>nlevels:金字塔层数；</li><li>edgeThreshold:边界阈值；</li><li>firstLevel:起始层； </li><li>WTA_K：描述子形成方法,WTA_K&#x3D;2表示，采用两两比较；</li><li>scoreType:角点响应函数，可以选择Harris或者Fast的方法；</li><li>patchSize:特征点邻域大小</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int  main()&#123;    cv::Mat image&#x3D;cv::imread(&quot;1.jpg&quot;);    cv::Mat grayImage;    cv::cvtColor(image,grayImage,CV_BGR2GRAY);    vector&lt;KeyPoint&gt; keypoints_1;    Mat descriptors_1;    Ptr&lt;FeatureDetector&gt; detector &#x3D; ORB::create();    Ptr&lt;DescriptorExtractor&gt; descriptor &#x3D; ORB::create();     &#x2F;&#x2F;-- 第一步:检测 Oriented FAST 角点位置    detector-&gt;detect ( grayImage,keypoints_1 );    &#x2F;&#x2F;-- 第二步:根据角点位置计算 BRIEF 描述子    descriptor-&gt;compute ( grayImage, keypoints_1, descriptors_1 );    Mat outimg1;    Mat outimg2;    &#x2F;&#x2F;-- 第三步:显示特征点    drawKeypoints( grayImage, keypoints_1, outimg1, Scalar::all(-1), DrawMatchesFlags::DEFAULT );    drawKeypoints( grayImage, keypoints_1, outimg2, Scalar::all(-1), DrawMatchesFlags::DRAW_RICH_KEYPOINTS );    imshow(&quot;ORB特征点&quot;,outimg1);    imshow(&quot;ORB特征方向圆&quot;,outimg2);    cv::waitKey();    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/pic/%E9%80%89%E5%8C%BA_041.png"></p><p><strong>特征提取及形成描述子</strong></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void ORB::operator()( InputArray _image, InputArray _mask, vector&lt;KeyPoint&gt;&amp; _keypoints,                        OutputArray _descriptors, bool useProvidedKeypoints)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li>_image:输入图像；</li><li>_mask:掩码图像;</li><li>_keypoints:输入角点；</li><li>_descriptors:如果为空，只寻找特征点，不计算特征描述子；</li><li>_useProvidedKeypoints:如果为true,函数只计算特征描述子</li></ul>]]></content>
      
      
      <categories>
          
          <category> Opencv </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Opencv </tag>
            
            <tag> Harris </tag>
            
            <tag> SIFT </tag>
            
            <tag> SURF </tag>
            
            <tag> ORB </tag>
            
            <tag> FAST </tag>
            
            <tag> BRIEF描述子 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>服务器开发与工具使用（vscode,anaconda,DL等）</title>
      <link href="/2023/03/31/net/"/>
      <url>/2023/03/31/net/</url>
      
        <content type="html"><![CDATA[<h1 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h1><p>首先拥有一个属于自己的服务器账号，包括服务器ip，端口，用户名以及密码等。</p><p>接着，需要安装ssh,一般linux系统都自带ssh，windows一般自带ssh客户端。如未安装，可查看以下教程安装</p><p><a href="https://blog.csdn.net/weixin_50964512/article/details/123588745">ssh安装与配置，详解版</a></p><p><a href="https://blog.csdn.net/qq_33594636/article/details/128849482">Windows安装和启动SSH服务</a></p><h2 id="软件安装"><a href="#软件安装" class="headerlink" title="软件安装"></a>软件安装</h2><p><strong>xftp7以及xshell7的安装</strong></p><ul><li><p>Xftp7是一个功能强大但轻量级的SFTP&#x2F;FTP客户机，用于需要在网络上安全地传输文件的用户。通过使用 拖放、直接编辑、增强的同步、传输调度和更直观的选项卡界面等特性，文件传输得到了简化。</p></li><li><p>Xshell 是一个强大的安全终端模拟软件，它支持SSH1、SHH2、以及 Microsoft Windows 平台的TELNET协议。Xshell 通过互联网到远程主机的安全连接以及它创新性的设计和特色帮助用户在复杂的网络环境中享受他们的工作。</p></li><li><p>Xshell 可以在 Windows 界面下用来访问远端不同系统下的服务器，从而比较好的达到远程控制终端的目的。除此之外，其还有丰富的外观配色方案以及样式选择。</p></li></ul><p>下载需要填个邮箱，之后它会给你的邮箱发个下载链接，点击下载链接安装即可。</p><p><a href="https://www.xshell.com/zh/free-for-home-school/">学生版下载网址</a></p><p><a href="https://www.xshell.com/">官网网址</a></p><p><strong>vscode软件安装</strong></p><p>Visual Studio Code 简称 VSCode ，2015 年由微软公司发布。</p><p>可用于 Windows，macOS 和 Linux。它具有对 JavaScript，TypeScript 和 Node.js 的内置支持，并具有丰富的其他语言（例如 C++，C＃，Java，Python，PHP，Go</p><p><a href="https://code.visualstudio.com/">vscode下载官网</a></p><p><a href="https://blog.csdn.net/weixin_44950987/article/details/128129613">vscode安装教程</a></p><p><strong>vscode链接远程服务器</strong></p><p>在vscode软件里安装插件<em><strong>Remote-SSH</strong></em>，安装完成后需要添加服务器连接配置，具体操作如下链接：</p><p><a href="https://blog.csdn.net/zhaxun/article/details/120568402">vscode连接远程服务器</a></p><blockquote><p>总结：xftp7用来传数据，xshell7与vscode都可以通过命令行形式对远程服务器进行操控，其中vscode依靠它强大的性能可以直接对服务器中个人程序进行图形化编写，运行，调试等</p></blockquote><h1 id="服务器中开发环境配置"><a href="#服务器中开发环境配置" class="headerlink" title="服务器中开发环境配置"></a>服务器中开发环境配置</h1><h2 id="Anaconda-x2F-miniconda安装"><a href="#Anaconda-x2F-miniconda安装" class="headerlink" title="Anaconda&#x2F;miniconda安装"></a>Anaconda&#x2F;miniconda安装</h2><p>对于需要进行深度学习的同学，需要安装Anaconda以管理自己的服务器环境，对于本实验室的服务器，可直接访问&#x2F;share&#x2F;software来获得此前下载过的Anaconda各版本</p><p>如果想自己安装不同版本的anaconda，请查看如下教程：</p><p><a href="https://zhuanlan.zhihu.com/p/32925500">Anaconda介绍，安装及使用教程</a></p><p><a href="https://blog.csdn.net/qq_42257666/article/details/121383450">anaconda安装配置教程</a></p><p><strong>conda是Anaconda提供的一个管理版本和Python环境的工具，我们一般都使用它创建虚拟环境，能够隔离不同的Python软件包环境，也不会影响到其他用户。强烈建议每个用户单独将它安装在用户目录用于Python环境管理。不建议使用系统自带的Python环境。</strong></p><p><a href="https://zhuanlan.zhihu.com/p/537439636">conda的使用,创建虚拟环境</a></p><p>安装完成之后，可以替换镜像源为清华源，安装软件包时速度一般能更快，换源教程如下：</p><p><a href="https://blog.csdn.net/qq_43115981/article/details/129064657">anaconda换源</a></p><h2 id="在自己创建的虚拟环境中安装PyTorch"><a href="#在自己创建的虚拟环境中安装PyTorch" class="headerlink" title="在自己创建的虚拟环境中安装PyTorch"></a>在自己创建的虚拟环境中安装PyTorch</h2><p>参照官网，选择好对应的cuda版本和python语言以及linux系统即可。</p><p>注意使用conda安装时，会自动安装cudatoolkit与cudnn，</p><p><a href="https://pytorch.org/">pytorch官网</a></p><p><a href="https://pytorch.org/get-started/previous-versions/">pytorch以往版本</a></p><p>安装好pytorch后，就可以开始自己的深度学习编程之旅了~~~</p><h1 id="深度学习教程"><a href="#深度学习教程" class="headerlink" title="深度学习教程"></a>深度学习教程</h1><p>这里推荐一些深度学习教程</p><p><a href="https://zh-v2.d2l.ai/">动手学深度学习</a></p><p><a href="hhttps://www.bilibili.com/video/BV1FT4y1E74V/?p=3&vd_source=c3ce2553ecbf3f37d2f4be6f466233fa">吴恩达深度学习</a></p><p><a href="https://www.bilibili.com/video/BV1nJ411z7fe/?spm_id_from=333.337.search-card.all.click&vd_source=c3ce2553ecbf3f37d2f4be6f466233fa">斯坦福李飞飞cs231n计算机视觉课程【附中文字幕】</a></p><p>强烈推荐B站UP主：<a href="https://space.bilibili.com/18161609/channel/series">霹雳吧啦Wz</a></p><p>他对深度学习基础的网络进行了详细的讲解并附上源码，包括图像分类、语义分割、关键点检测、目标检测，实例分割等，强烈推荐学习</p><p><a href="https://github.com/WZMIAOMIAO/deep-learning-for-image-processing">源码地址</a></p><p>另外推荐一些开源的深度学习开源工具箱，零基础上手就可以跑起来</p><p><a href="https://github.com/open-mmlab">OpenMMLab 平台</a></p><p><a href="https://github.com/open-mmlab/mmdetection">MMDetection基于 PyTorch 的目标检测开源工具箱</a></p><p><a href="https://github.com/open-mmlab/mmyolo">mmyolo基于 PyTorch 和 MMDetection 的 YOLO 系列算法开源工具箱</a></p>]]></content>
      
      
      <categories>
          
          <category> net </category>
          
          <category> DL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> net </tag>
            
            <tag> ssh </tag>
            
            <tag> DL </tag>
            
            <tag> vscode </tag>
            
            <tag> anaconda </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ROS介绍及快速体验</title>
      <link href="/2023/03/30/ros/"/>
      <url>/2023/03/30/ros/</url>
      
        <content type="html"><![CDATA[<h1 id="ROS概念"><a href="#ROS概念" class="headerlink" title="ROS概念"></a>ROS概念</h1><p><strong>ROS全称Robot Operating System(机器人操作系统)</strong></p><ul><li><p>ROS是适用于机器人的开源元操作系统</p></li><li><p>ROS集成了大量的工具，库，协议，提供类似OS所提供的功能，简化对机器人的控制</p></li><li><p>还提供了用于在多台计算机上获取，构建，编写和运行代码的工具和库，ROS在某些方面类似于“机器人框架”</p></li><li><p>ROS设计者将ROS表述为“ROS &#x3D; Plumbing + Tools + Capabilities + Ecosystem”，即ROS是通讯机制、工具软件包、机器人高层技能以及机器人生态系统的集合体</p></li></ul><p><img src="/pic/%E9%80%89%E5%8C%BA_028.png"></p><h1 id="ROS框架"><a href="#ROS框架" class="headerlink" title="ROS框架"></a>ROS框架</h1><p>ROS 框架主要分成三个层级，分别是 ROS 文件系统、ROS 计算图和 ROS 社区。</p><h2 id="ROS文件系统"><a href="#ROS文件系统" class="headerlink" title="ROS文件系统"></a>ROS文件系统</h2><p>ROS 的文件系统主要介绍了硬盘上 ROS 文件的组织形式。其中，我们必须了解的主要有以下几个方面：</p><ul><li>软件包（Package）：ROS 软件包是 ROS 软件框架的独立单元。ROS 软件包可能包含源代码、第三方软件库、配置文件等。ROS 软件包可以复用和共享。</li><li>软件包清单（Package Manifest）：清单文件（package.xml）列出了软件包的所有详细信息，包括名称、描述、许可信息以及最重要的依赖关系。</li><li>消息（msg）类型：消息的描述存储在软件包的 msg 文件夹下。ROS 消息是一组通过 ROS 的消息传递系统进行数据发送的数据结构。消息的定义存储在扩展名为 .msg 的文件里。</li><li>服务（srv）类型：服务的描述使用扩展名 .srv 存储在 srv 文件夹下。该文件定义了 ROS 内服务请求和响应的数据结构。</li></ul><p><img src="/pic/%E9%80%89%E5%8C%BA_029.png"></p><pre class="line-numbers language-none"><code class="language-none">WorkSpace --- 自定义的工作空间    |--- build:编译空间，用于存放CMake和catkin的缓存信息、配置信息和其他中间文件。    |--- devel:开发空间，用于存放编译后生成的目标文件，包括头文件、动态&amp;静态链接库、可执行文件等。    |--- src: 源码        |-- package：功能包(ROS基本单元)包含多个节点、库与配置文件，包名所有字母小写，只能由字母、数字与下划线组成            |-- CMakeLists.txt 配置编译规则，比如源文件、依赖项、目标文件            |-- package.xml 包信息，比如:包名、版本、作者、依赖项...(以前版本是 manifest.xml)            |-- scripts 存储python文件            |-- src 存储C++源文件            |-- include 头文件            |-- msg 消息通信格式文件            |-- srv 服务通信格式文件            |-- action 动作格式文件            |-- launch 可一次性运行多个节点             |-- config 配置信息        |-- CMakeLists.txt: 编译的基本配置<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="ROS计算图"><a href="#ROS计算图" class="headerlink" title="ROS计算图"></a>ROS计算图</h2><p>ros 程序运行之后，不同的节点之间是错综复杂的，ROS 中提供了一个实用的工具:rqt_graph。</p><p>rqt_graph能够创建一个显示当前系统运行情况的动态图形。ROS 分布式系统中不同进程需要进行数据交互，计算图可以以点对点的网络形式表现数据交互过程。rqt_graph是rqt程序包中的一部分。</p><p>ROS 计算图中的基本功能包括节点、ROS 控制器、参数服务器、消息和服务：</p><ul><li><strong>节点（Node）</strong>：ROS 节点是使用 ROS 功能处理数据的进程。节点的基本功能是计算。例如，节点可以对激光扫描仪数据进行处理，以检查是否存在碰撞。ROS 节点的编写需要 ROS 客户端库文件（如roscpp和rospy）的支持。</li><li><strong>ROS 控制器（Master）</strong>：ROS 节点可以通过名为 ROS 控制器的程序相互连接。此程序提供计算图其他节点的名称、注册和查找信息。如果不运行这个控制器，节点之间将无法相互连接和发送消息。</li><li><strong>参数服务器（Parameter server）</strong>：ROS 参数是静态值，存储在叫作参数服务器的全局位置。所有节点都可以从参数服务器访问这些值。我们甚至可以将参数服务器的范围设置为 private 以访问单个节点，或者设置为 public 以访问所有节点。</li><li><strong>ROS主题（Topic）</strong>：ROS 节点使用命名总线（叫作 ROS 主题）彼此通信。数据以消息的形式流经主题。通过主题发送消息称为发布，通过主题接收数据称为订阅。</li><li><strong>消息（Message）</strong>：ROS 消息是一种数据类型，可以由基本数据类型（如整型、浮点型、布尔类型等）组成。ROS 消息流经 ROS 主题。一个主题一次只能发送&#x2F;接收一种类型的消息。我们可以创建自己的消息定义并通过主题发送它。</li><li><strong>服务（Service）</strong>：我们看到使用 ROS 主题的发布&#x2F;订阅模型是一种非常灵活的通信模式，这是一种一对多的通信模式，意味着一个主题可以被任意数量的节点订阅。在某些情况下，可能还需要一种<strong>请求&#x2F;应答</strong>类型的交互方式，它可以用于分布式系统。这种交互方式可以使用 ROS 服务实现。ROS 服务的工作方式与 ROS 主题类似，因为它们都有消息类型定义。使用该消息定义可以将服务请求发送到另一个提供该服务的节点。服务的结果将作为应答发送。该节点必须等待，直到从另一个节点接收到结果。</li><li><strong>ROS 消息记录包（Bag）</strong>：这是一种用于保存和回放 ROS 主题的文件格式。ROS 消息记录包是记录传感器数据和处理数据的重要工具。这些包之后可以用于离线测试算法</li></ul><blockquote><p>演示</p></blockquote><p>首先，按照前面所示，运行案例</p><p>然后，启动新终端，键入: rqt_graph 或 rosrun rqt_graph rqt_graph，可以看到类似下图的网络拓扑图，该图可以显示不同节点之间的关系。</p><p><img src="/pic/%E9%80%89%E5%8C%BA_030.png"></p><h2 id="ROS快速体验"><a href="#ROS快速体验" class="headerlink" title="ROS快速体验"></a>ROS快速体验</h2><h3 id="HelloWorld实现简介"><a href="#HelloWorld实现简介" class="headerlink" title="HelloWorld实现简介"></a>HelloWorld实现简介</h3><p>ROS中涉及的编程语言以C++和Python为主，ROS中的大多数程序两者都可以实现,ROS中的程序即便使用不同的编程语言，实现流程也大致类似，以当前HelloWorld程序为例，实现流程大致如下：</p><ul><li>先创建一个工作空间；</li><li>再创建一个功能包；</li><li>编辑源文件；</li><li>编辑配置文件；</li><li>编译并执行。</li></ul><p><strong>1.创建工作空间并初始化</strong></p><pre class="line-numbers language-none"><code class="language-none">mkdir -p 自定义空间名称&#x2F;srccd 自定义空间名称catkin_make<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>2.进入 src 创建 ros 包并添加依赖</strong></p><pre class="line-numbers language-none"><code class="language-none">cd srccatkin_create_pkg 自定义ROS包名 roscpp rospy std_msgs<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>上述命令，会在工作空间下生成一个功能包，该功能包依赖于** <em>roscpp、rospy 与 std_msgs</em>**，其中roscpp是使用C++实现的库，而rospy则是使用python实现的库，std_msgs是标准消息库，创建ROS功能包时，一般都会依赖这三个库实现。</p><p><em><strong>补充</strong></em> ：在ROS中，虽然实现同一功能时，C++和Python可以互换，但是具体选择哪种语言，需要视需求而定，因为两种语言相较而言:C++运行效率高但是编码效率低，而Python则反之，基于二者互补的特点，ROS设计者分别设计了roscpp与rospy库，前者旨在成为ROS的高性能库，而后者则一般用于对性能无要求的场景，旨在提高开发效率。</p><h3 id="HelloWorld-C-版"><a href="#HelloWorld-C-版" class="headerlink" title="HelloWorld(C++版)"></a>HelloWorld(C++版)</h3><p><strong>1.进入 ros 包的 src 目录编辑源文件</strong></p><pre class="line-numbers language-none"><code class="language-none">cd 自定义的包<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>C++源码实现(文件名自定义)</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &quot;ros&#x2F;ros.h&quot;int main(int argc, char *argv[])&#123;    &#x2F;&#x2F;执行 ros 节点初始化    ros::init(argc,argv,&quot;hello&quot;);    &#x2F;&#x2F;创建 ros 节点句柄(非必须)    ros::NodeHandle n;    &#x2F;&#x2F;控制台输出 hello world    ROS_INFO(&quot;hello world!&quot;);    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>2.编辑 ros 包下的 Cmakelist.txt文件</strong></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">add_executable(步骤3的源文件名  src&#x2F;步骤3的源文件名.cpp)target_link_libraries(步骤3的源文件名  $&#123;catkin_LIBRARIES&#125;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>3.进入工作空间目录并编译</strong></p><pre class="line-numbers language-none"><code class="language-none">cd 自定义空间名称catkin_make<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>生成 build devel ….</p><p><strong>4.执行</strong></p><p><em>先启动命令行1：</em></p><pre class="line-numbers language-none"><code class="language-none">roscore<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><em>再启动命令行2：</em></p><pre class="line-numbers language-none"><code class="language-none">cd 工作空间source .&#x2F;devel&#x2F;setup.bashrosrun 包名 C++节点<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>命令行输出: HelloWorld!</p><p><em><strong>补充</strong></em>：source ~&#x2F;工作空间&#x2F;devel&#x2F;setup.bash可以添加进.bashrc文件，使用上更方便</p><p><strong>添加方式1: 直接使用 gedit 或 vi 编辑 .bashrc 文件，最后添加该内容</strong></p><p><strong>添加方式2:echo “source ~&#x2F;工作空间&#x2F;devel&#x2F;setup.bash” &gt;&gt; ~&#x2F;.bashrc</strong></p><blockquote><p>参考文献</p></blockquote><p><a href="http://c.biancheng.net/view/9853.html">ROS机器人操作系统简介</a></p><p><a href="http://www.autolabor.com.cn/book/ROSTutorials/chapter1/15-ben-zhang-xiao-jie/153-rosji-suan-tu.html">机器人入门教程</a></p>]]></content>
      
      
      <categories>
          
          <category> ROS </category>
          
          <category> c++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ros </tag>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RANSAC、LMEDS以及Hough变换原理</title>
      <link href="/2023/03/28/ransac/"/>
      <url>/2023/03/28/ransac/</url>
      
        <content type="html"><![CDATA[<h1 id="RANSAC算法简介"><a href="#RANSAC算法简介" class="headerlink" title="RANSAC算法简介"></a>RANSAC算法简介</h1><p>RANSAC是”RANdom SAmple Consensus”（随机采样一致）的缩写。它可以从一组包含“局外点”的观测数据集中，通过迭代方式估计数学模型的参数，它是一种不确定的算法—-它有一定的概率得出一个合理的结果；为了提高概率必须提高迭代次数。</p><blockquote><p>RANSAC基本假设</p></blockquote><ul><li>数据由<strong>局内点</strong>组成， 例如，数据的分布可以用一些模型（比如直线方程）参数来解释；</li><li><strong>局外点</strong>是不能适应该模型的参数；</li><li>除此之外的数据属于噪声；</li></ul><p>局外点产生的原因有：噪声的极值；错误的测量方法；对数据的错误假设等；</p><blockquote><p>RANSAC概述</p></blockquote><p>RANSAC算法的输入时一组观测数据，一个可以解释或者适应于观测数据的参数化模型，一些可行的参数。</p><p>RANSAC通过反复选择数据中的一组随机子集来达成目标。被选取的子集被假设为局内点，并用下述方法进行验证：</p><ul><li>有一个模型适应于假定的局内点，即所有的未知参数都能从假设的局内点计算得出；</li><li>用1中得到的模型去测试所有的其它数据，如果某个点适用于估计的模型，认为他也是局内点；</li><li>如果有足够多的点呗归类为假设的局内点，那么估计的模型就足够合理；</li><li>然后，用所有假设的局内点去重新估计模型，因为它仅仅被初始的假设局内点估计过；</li><li>最后，通过估计局内点与模型的错误率来评估模型；</li></ul><p>这个过程被重复执行固定的次数，每次产生的模型要么因为局内点太少而被抛弃，要么因为比现有的模型更好而被选用。</p><p>关于模型好坏算法实现上有两种方式：</p><ul><li>规定一个点数，达到这个点数后，算这些点与模型间的误差，找误差最小的模型。 对应下面算法一</li><li>规定一个误差，找匹配模型并小于这个误差的所有点，匹配的点最多的模型，就是最好模型。 对应下面算法二</li></ul><p>算法伪代码一：</p><pre class="line-numbers language-伪代码" data-language="伪代码"><code class="language-伪代码">输入：data ---- 一组观测数据model ---- 适应于数据的模型n ---- 适用于模型的最少数据个数k ---- 算法的迭代次数t ---- 用于决定数据是否适应于模型的阈值d ---- 判定模型是否适用于数据集的数据数目输出：best_model —— 跟数据最匹配的模型参数（如果没有找到，返回null）best_consensus_set —— 估计出模型的数据点best_error —— 跟数据相关的估计出的模型的错误iterations &#x3D; 0best_model &#x3D; nullbest_consensus_set &#x3D; nullbest_error &#x3D; 无穷大while( iterations &lt; k )    maybe_inliers &#x3D;  从数据集中随机选择n个点    maybe_model &#x3D; 适合于maybe_inliers的模型参数    consensus_set &#x3D; maybe_inliers    for (每个数据集中不属于maybe_inliers的点)        if （如果点适合于maybe_model，并且错误小于t）           将该点添加到consensus_set    if (consensus_set中的点数大于d)        已经找到了好的模型， 现在测试该模型到底有多好       better_model &#x3D; 适用于consensus_set中所有点的模型参数       this_error &#x3D;  better_model 究竟如何适合这些点的度量        if （this_error &lt; best_error）        发现比以前好的模型，保存该模型直到更好的模型出现        best_model &#x3D; better_model        best_consensus_set &#x3D; consensus_set        best_error &#x3D; this_error    iterations ++函数返回best_model, best_consensus_set, best_error<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>RANSAC算法的可能变化包括以下几种：</p><ul><li>如果发现一种足够好的模型（该模型有足够下的错误率）， 则跳出主循环，这样节约不必要的计算；设置一个错误率的阈值，小于这个值就跳出循环；</li><li>可以直接从maybe_model计算this_error，而不从consensus_set重新估计模型，这样可能会节约时间，但是可能会对噪音敏感。</li></ul><p>算法伪代码二：</p><pre class="line-numbers language-伪代码" data-language="伪代码"><code class="language-伪代码">输入：data ---- 一组观测数据numForEstimate ----- 初始模型需要的点数delta ------ 判定点符合模型的误差probability ----- 表示迭代过程中从数据集内随机选取出的点均为局内点的概率输出：best_model —— 跟数据最匹配的模型参数（如果没有找到，返回null）best_consensus_set —— 估计出模型的数据点k &#x3D; 1000&#x2F;&#x2F;设置初始值iterations &#x3D; 0best_model &#x3D; nullbest_consensus_set &#x3D; nullwhile( iterations &lt; k )    maybe_inliers &#x3D;  从数据集中随机选择numForEstimate个点    maybe_model &#x3D; 适合于maybe_inliers的模型参数，比如直线，取两个点，得直线方程    for (每个数据集中不属于maybe_inliers的点)        if （如果点适合于maybe_model，并且错误小于delta）            将该点添加到maybe_inliers    if(maybe_inliers的点数 &gt; best_consensus_set 的点数）&#x2F;&#x2F;找到更好的模型        best_model &#x3D; maybe_model        best_consensus_set  &#x3D; maybe_inliers        根据公式k&#x3D;log(1-p)&#x2F;log(1-pow(w,n))重新计算k    iterations ++函数返回best_model, best_consensus_set,<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="RANSAC参数"><a href="#RANSAC参数" class="headerlink" title="RANSAC参数"></a>RANSAC参数</h2><p>我们不得不根据特定的问题和数据集通过实验来确定参数t和d。然而参数k（迭代次数）可以从理论结果推断。当我们从估计模型参数时，用p表示一些迭代过程中从数据集内随机选取出的点均为局内点的概率；此时，结果模型很可能有用，因此p也表征了算法产生有用结果的概率。用w表示每次从数据集中选取一个局内点的概率，如下式所示： w &#x3D; 局内点的数目 &#x2F; 数据集的数目 通常情况下，我们事先并不知道w的值，但是可以给出一些鲁棒的值。假设估计模型需要选定n个点，wn是所有n个点均为局内点的概率；1 − wn是n个点中至少有一个点为局外点的概率，此时表明我们从数据集中估计出了一个不好的模型。 (1 − wn)k表示算法永远都不会选择到n个点均为局内点的概率，它和1-p相同。因此，<br>$$<br>1-p&#x3D;\left(1-w^n\right)^k<br>$$</p><p>其中</p><ul><li><p>p 表示置信度confidence</p></li><li><p>w 表示数据集中inlier占的比例</p></li><li><p>n 表示采样点数</p></li><li><p>k 表示需要迭代采样的最少次数</p></li><li><p>1 − wn 表示采样一次，n个点中至少有一个outlier的概率</p></li><li><p>(1 − wn)k 表示采样k次，n个点中至少有一个outlier的概率</p></li><li><p>因为p为采样k次，能有至少一次n个点都是inlier的概率</p></li><li><p>所以(1 − p)和(1 − wn)k相等时，k 为需要迭代采样的最少次数</p></li></ul><p>下面是k的解析解：</p><p>$$<br>k&#x3D;\frac{\log (1-p)}{\log \left(1-w^n\right)}<br>$$</p><p>值得注意的是，这个结果假设n个点都是独立选择的；也就是说，某个点被选定之后，它可能会被后续的迭代过程重复选定到。这种方法通常都不合理，由此推导出的k值被看作是选取不重复点的上限。例如，要从上图中的数据集寻找适合的直线，RANSAC算法通常在每次迭代时选取2个点，计算通过这两点的直线maybe_model，要求这两点必须唯一。</p><p>为了得到更可信的参数，标准偏差或它的乘积可以被加到k上。k的标准偏差定义为：</p><p>$$<br>S D(k)&#x3D;\frac{\sqrt{1-w^n}}{w^n}<br>$$</p><blockquote><p>RANSAC的函数接口 参照opencv来说主要需要3-4个参数（第四个不是必须的）</p></blockquote><ul><li>误差阈值ransacThreshold：区分inlier和outliner的依据</li><li>置信度confidence：设置之后代表RANSAC采样n次过程中会出现（至少一次）采样点数据集中的点都为内点的概率。这个值设置的太大，会增加采样次数。太小，会使结果不太理想。一般取0.95-0.99</li><li>最大采样迭代次数maxIters：为了防止一直在采样计算</li><li>最大精细迭代次数refineIters：在采样之后，选取最优解。可以增加精确优化，比如使用LM算法获得更优解。</li></ul><p>以上4个参数，有三个是经验值。其中最大采样迭代次数maxIters是可以有数值解的。</p><h2 id="RANSAC优点与缺点"><a href="#RANSAC优点与缺点" class="headerlink" title="RANSAC优点与缺点"></a>RANSAC优点与缺点</h2><p>RANSAC的优点是它能鲁棒的估计模型参数。例如，它能从包含大量局外点的数据集中估计出高精度的参数。</p><p>RANSAC的缺点是它计算参数的迭代次数没有上限；如果设置迭代次数的上限，得到的结果可能不是最优的结果，甚至可能得到错误的结果。RANSAC只有一定的概率得到可信的模型，概率与迭代次数成正比。RANSAC的另一个缺点是它要求设置跟问题相关的阀值。</p><p>RANSAC只能从特定的数据集中估计出一个模型，如果存在两个（或多个）模型，RANSAC不能找到别的模型。如果有多个模型，可以先估算出一个，然后用剩余的数据重新运算，重复这个过程，直到没有模型。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="https://www.cnblogs.com/xrwang/archive/2011/03/09/ransac-1.html">王先荣RANSAC介绍</a></p><p><a href="https://zhuanlan.zhihu.com/p/402727549">RANSAC详解，保姆级教程</a></p><p><a href="https://zhuanlan.zhihu.com/p/45532306">计算机视觉基本原理</a></p><h2 id="RANSAC应用"><a href="#RANSAC应用" class="headerlink" title="RANSAC应用"></a>RANSAC应用</h2><p>OpenCV中使用RANSAC算法实现多张图像拼接思路：</p><ul><li><p>获取图像的特征点，将每张图片的特征点保存到一个vector中；</p></li><li><p>通过特征点匹配的方法，找到每张图片的共有特征点，并将其保存到一个vector中；</p></li><li><p>通过RANSAC算法求解出拼接的变换矩阵；</p></li><li><p>根据变换矩阵对每张图片进行仿射变换；</p></li><li><p>将拼接后的图片进行裁剪；</p></li><li><p>将裁剪后的图片拼接起来，最终得到拼接后的图片。</p></li></ul><p><a href="https://blog.csdn.net/qq_39312146/article/details/129053592">OpenCV中使用RANSAC算法实现多张图像拼接</a></p><p>OpenCV中的solvePnPRansac函数和findHomography函数都具有RANSAC特性，该特性使算法对少量的错误数据鲁棒。<br>这两个函数利用RANSACPointSetRegistrator类实现RANSAC算法，但这个类并没有对外开放，因此只能通过阅读OpenCV源代码学习RANSAC算法的实现和使用。</p><p>类的实现在ptsetreg.cpp中，可通过调用precomp.hpp文件中的createRANSACPointSetRegistrator函数使用。此外，该文件还提供了createLMeDSPointSetRegistrator函数调用最小中值算法。</p><p><a href="https://blog.csdn.net/HopefulLight/article/details/78775974">在OpenCV中使用RANSAC</a></p><h1 id="LMEDS算法概述（最小中值法：Least-Median-of-Squares）"><a href="#LMEDS算法概述（最小中值法：Least-Median-of-Squares）" class="headerlink" title="LMEDS算法概述（最小中值法：Least Median of Squares）"></a>LMEDS算法概述（最小中值法：Least Median of Squares）</h1><blockquote><p>经典步骤</p></blockquote><ul><li><p>随机采样</p></li><li><p>计算模型参数</p></li><li><p>计算相对模型的点集偏差err，并求出偏差中值Med(err)</p></li><li><p>迭代2. 3.步直至获得符合阈值的最优解：Med(err)最小</p></li><li><p>精确优化模型参数（LM算法迭代优化）</p></li></ul><blockquote><p>LMedS的函数接口 参照opencv来说主要需要2-3个参数（第三个不是必须的）</p></blockquote><ul><li><p>置信度confidence：设置之后代表RANSAC采样n次过程中会出现（至少一次）采样点数据集中的点都为内点的概率，这个值设置的太大，会增加采样次数。太小，会使结果不太理想。一般取0.95-0.99</p></li><li><p>最大采样迭代次数maxIters：为了防止一直在采样计算</p></li><li><p>最大精细迭代次数refineIters：在采样之后，选取最优解。可以增加精确优化，比如使用LM算法获得更优解。</p></li></ul><p>注意： 相对于RANSAC，LMedS有一个优点：不需要指定 - 误差阈值ransacThreshold：区分inlier和outliner的依据</p><blockquote><p>RANSAC与LMEDS两者的区别</p></blockquote><p><em><strong>RANSAC的阈值在具有物理意义或者几何意义的时候比较容易确定，但是当阈值不具有这些特征的时候，就成了一个不太好调整的参数了。这时LMedS可以自适应迭代获得最优解。</strong></em></p><blockquote><p>此外，LMedS也能自适应获得inlier和outliner,公式如下：</p></blockquote><p>$$<br>\hat{\sigma}&#x3D;1.4826\left(1+\frac{5}{n-p}\right) \operatorname{med}_i \sqrt{r_i^2}<br>$$</p><p>其中</p><ul><li><p>n 表示点集的个数</p></li><li><p>p 表示计算模型一次采样的点个数</p></li><li><p>ri2  表示误差</p></li><li><p>med(ri2 ) 表示误差中值</p></li></ul><p> 筛选条件为：</p> <!-- $$w_i=\left\{\begin{array}{cc}1 & \frac{\left|r_i\right|}{\hat{\sigma}} \leq 2.5 \\ 0 & \frac{\left|r_i\right|}{\hat{\sigma}}>2.5\end{array}\right.$$ --><p><img src="/pic/%E9%80%89%E5%8C%BA_027.png"></p><p><strong>由于LMedS会需要对整个点集的err求中值，当点集很大的时候，求中值的过程会很消耗时间</strong></p><p><a href="https://blog.csdn.net/billbliss/article/details/78592216">RANSAC LMedS 详细分析</a></p><h1 id="霍夫变换-Hough"><a href="#霍夫变换-Hough" class="headerlink" title="霍夫变换(Hough)"></a>霍夫变换(Hough)</h1><p><strong>霍夫变换</strong>是一种特征提取(feature extraction)，被广泛应用在图像分析（image analysis）、计算机视觉(computer vision)以及数位影像处理(digital image processing)。霍夫变换是用来辨别找出物件中的特征，例如：线条。他的算法流程大致如下，给定一个物件、要辨别的形状的种类，算法会在参数空间(parameter space)中执行投票来决定物体的形状，而这是由累加空间(accumulator space)里的局部最大值(local maximum)来决定。</p><p>经典的霍夫变换是侦测图片中的直线，之后，霍夫变换不仅能识别直线，也能够识别任何形状，常见的有圆形、椭圆形。1981年，因为DanaH.Ballard的一篇期刊论文”Generalizing the Hough transform to detect arbitrary shapes”，让霍夫变换开始流行于计算机视觉界。</p><p><a href="https://zhuanlan.zhihu.com/p/47649796">霍夫变换-神奇的特征提取方法</a></p><p><a href="https://zhuanlan.zhihu.com/p/203292567">通俗易懂-霍夫变换原理</a></p><p><a href="https://zhuanlan.zhihu.com/p/386048978">霍夫变换及代码实现</a></p>]]></content>
      
      
      <categories>
          
          <category> Opencv </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Opencv </tag>
            
            <tag> RANSAC </tag>
            
            <tag> LMEDS </tag>
            
            <tag> Hough </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>视觉及其融合惯性SLAM技术发展综述</title>
      <link href="/2023/03/27/slam/"/>
      <url>/2023/03/27/slam/</url>
      
        <content type="html"><![CDATA[<h1 id="SLAM技术"><a href="#SLAM技术" class="headerlink" title="SLAM技术"></a>SLAM技术</h1><p>同步定位与建图（Simultaneous Localization and Mapping，简称SLAM）问题可以描述为：机器人在未知环境中从一个未知位置开始移动,在移动过程中根据位置和地图进行自身定位，同时在自身定位的基础上建造增量式地图，实现机器人的自主定位和导航。</p><blockquote><p>SLAM 技术主要呈现以下 3 点发展趋势。</p></blockquote><ul><li>理论优化改进：由于应用场景需求的多样化，结合惯性、异源图像等多传感器的信息融合模式成为 SLAM 主流，促进了以紧耦合为主的信息融合理论发展，而随着大场景 SLAM 应用需求及图优化理论的推进，逐步形成了<strong>基于扩展卡尔曼滤波</strong>框架的改进滤波器优化架构，和以<strong>光束法平差（BA）</strong>为主的非线性优化架构两种研究趋势。</li><li>新型技术引入：随着<strong>深度学习</strong>技术在计算机视觉中的广泛应用，视觉 SLAM 呈现出由传统几何变换方式逐步转向结合深度学习的智能融合趋势。一方面<strong>视觉图像与语义信息</strong>的紧密联系，使得集成语义信息的视觉 SLAM 得到更多探索；另一方面为减少对传统方式依赖，利用<strong>神经网络架构</strong>替代 SLAM 的部分模块或端到端<strong>强化学习</strong>的模式得以广泛研究。</li><li>应用领域推广：视觉 SLAM 目前在<em>智能家居、自动驾驶、无人机</em>等领域得到了不同层次的应用，随着硬件性能的提升，视觉 SLAM</li></ul><p><img src="/pic/%E5%9B%BE%E7%89%871.png" alt="视觉、惯性SLAM系统框架结构"></p><p><img src="/pic/%E5%9B%BE%E7%89%872.png" alt="视觉SLAM构建地图类型"></p><p><img src="/pic/%E5%9B%BE%E7%89%873.png"></p><p><img src="/pic/%E5%9B%BE%E7%89%874.png"></p><p><img src="/pic/%E5%9B%BE%E7%89%875.png"></p><p><img src="/pic/%E5%9B%BE%E7%89%876.png"></p><p><img src="/pic/%E5%9B%BE%E7%89%877.png" alt="标准视觉SLAM Pipeline"></p><p><img src="/pic/%E5%9B%BE%E7%89%878.png" alt="极具影响力的视觉SLAM方法"></p><blockquote><p>VSLAM 常用数据集：表内的GT 是指真值的可用性</p></blockquote><p><img src="/pic/%E5%9B%BE%E7%89%879.png"></p><p><img src="/pic/%E5%9B%BE%E7%89%8710.png" alt="各种论文中用于评估的一些主流视觉SLAM数据集的实例"></p>]]></content>
      
      
      
        <tags>
            
            <tag> slam </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图像变换(image_transformer)</title>
      <link href="/2023/03/27/image-transformer/"/>
      <url>/2023/03/27/image-transformer/</url>
      
        <content type="html"><![CDATA[<h1 id="图像变换"><a href="#图像变换" class="headerlink" title="图像变换"></a>图像变换</h1><p>基本的图像变换有<strong>刚性变换(等距变换、欧式变换)、相似变换、仿射变换、射影变换(透视变换、投影变换)</strong></p><blockquote><p>刚性变化：只对图像进行平移与旋转，形状保持不变</p></blockquote><p>欧式变换（等距变换）保持了向量的<strong>长度和夹角</strong>，相当于我们把一个刚体原封不动地进行移动或旋转，不改变它自身的样子</p><p><img src="/pic/%E9%80%89%E5%8C%BA_020.png" alt="刚体变换矩阵"></p><blockquote><p>相似变换： 等距变换与一个均匀缩放的复合；等距变换+ 均匀缩放，类似相似三角形，比例不变</p></blockquote><p>相似变换比欧氏变换多了一个自由度，它允许物体进行均匀的放缩，其矩阵表示形式为：</p><p><img src="/pic/%E9%80%89%E5%8C%BA_021.png" alt="相似变换矩阵"></p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> cv2<span class="token keyword">import</span> matplotlib<span class="token punctuation">.</span>pyplot <span class="token keyword">as</span> plt<span class="token keyword">import</span> numpy <span class="token keyword">as</span> npimg <span class="token operator">=</span> cv2<span class="token punctuation">.</span>imread<span class="token punctuation">(</span><span class="token string">'/hone/chy/pic/git.png'</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>img <span class="token operator">=</span> cv2<span class="token punctuation">.</span>cvtColor<span class="token punctuation">(</span>img<span class="token punctuation">,</span> cv2<span class="token punctuation">.</span>COLOR_BGR2RGB<span class="token punctuation">)</span><span class="token comment"># print(img.shape)</span><span class="token comment"># 得到相似变换的矩阵  # center：旋转中心 angle：旋转角度   scale：缩放比例</span>M <span class="token operator">=</span> cv2<span class="token punctuation">.</span>getRotationMatrix2D<span class="token punctuation">(</span>center <span class="token operator">=</span> <span class="token punctuation">(</span>img<span class="token punctuation">.</span>shape<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">,</span>img<span class="token punctuation">.</span>shape<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                              angle <span class="token operator">=</span> <span class="token number">30</span><span class="token punctuation">,</span>                              scale <span class="token operator">=</span> <span class="token number">0.5</span><span class="token punctuation">)</span> <span class="token comment"># 原图像按照相似矩阵进行相似变换  三个参数：原图像，相似矩阵，画布面积</span>img_rotate <span class="token operator">=</span> cv2<span class="token punctuation">.</span>warpAffine<span class="token punctuation">(</span>img<span class="token punctuation">,</span> M<span class="token punctuation">,</span> <span class="token punctuation">(</span>img<span class="token punctuation">.</span>shape<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> img<span class="token punctuation">.</span>shape<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>figure<span class="token punctuation">(</span>figsize<span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>subplot<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>imshow<span class="token punctuation">(</span>img<span class="token punctuation">)</span>plt<span class="token punctuation">.</span>subplot<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>imshow<span class="token punctuation">(</span>img_rotate<span class="token punctuation">)</span>plt<span class="token punctuation">.</span>show<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/pic/%E9%80%89%E5%8C%BA_019.png" alt="相似变换结果"></p><blockquote><p>仿射变换：非齐次坐标下的一个非奇异线性变换与一个平移变换的复合，（即第三行是0,0,1）; 旋转+平移+缩放+切变，保持平行性</p></blockquote><p>仿射变换只要求 A 是一个可逆矩阵，而不必是正交矩阵。仿射变换也叫正交投影。经过仿射变换之后，立方体就不再是方的了，但是各个面仍是平行四边形 </p><ul><li>性质：Parallel lines are still parallel lines（不再具有保角性，具有保平行性）</li><li>三个非共线的点对（6 parameters）确定一个仿射变换。</li></ul><p><img src="/pic/%E9%80%89%E5%8C%BA_022.png" alt="仿射变换矩阵"></p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> cv2<span class="token keyword">import</span> matplotlib<span class="token punctuation">.</span>pyplot <span class="token keyword">as</span> plt<span class="token keyword">import</span> numpy <span class="token keyword">as</span> np<span class="token comment"># 3 Src(原始) Points + 3 Dst(目标) Points</span><span class="token comment"># cols：列/长  rows：行/宽</span>img <span class="token operator">=</span> cv2<span class="token punctuation">.</span>imread<span class="token punctuation">(</span><span class="token string">'lenna.jpg'</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>img <span class="token operator">=</span> cv2<span class="token punctuation">.</span>cvtColor<span class="token punctuation">(</span>img<span class="token punctuation">,</span> cv2<span class="token punctuation">.</span>COLOR_BGR2RGB<span class="token punctuation">)</span><span class="token comment"># print(img.shape)</span>cols <span class="token operator">=</span> img<span class="token punctuation">.</span>shape<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>rows <span class="token operator">=</span> img<span class="token punctuation">.</span>shape<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>pt1 <span class="token operator">=</span> np<span class="token punctuation">.</span>float32<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>cols<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> rows<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span>pt2 <span class="token operator">=</span> np<span class="token punctuation">.</span>float32<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">[</span>cols<span class="token operator">*</span><span class="token number">0.3</span><span class="token punctuation">,</span> rows<span class="token operator">*</span><span class="token number">0.3</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>cols<span class="token operator">*</span><span class="token number">0.8</span><span class="token punctuation">,</span> rows<span class="token operator">*</span><span class="token number">0.2</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>cols<span class="token operator">*</span><span class="token number">0.1</span><span class="token punctuation">,</span> rows<span class="token operator">*</span><span class="token number">0.9</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token comment"># [[0,0], [cols, 0], [0, rows]] --> [[cols*0.3, rows*0.3], [cols*0.8, rows*0.2], [cols*0.1, rows*0.9]]</span>M <span class="token operator">=</span> cv2<span class="token punctuation">.</span>getAffineTransform<span class="token punctuation">(</span>pt1<span class="token punctuation">,</span> pt2<span class="token punctuation">)</span>       <span class="token comment"># 仿射变换矩阵</span>dst <span class="token operator">=</span> cv2<span class="token punctuation">.</span>warpAffine<span class="token punctuation">(</span>img<span class="token punctuation">,</span> M<span class="token punctuation">,</span> <span class="token punctuation">(</span>cols<span class="token punctuation">,</span> rows<span class="token punctuation">)</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>figure<span class="token punctuation">(</span>figsize<span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>subplot<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>imshow<span class="token punctuation">(</span>img<span class="token punctuation">)</span>plt<span class="token punctuation">.</span>subplot<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>imshow<span class="token punctuation">(</span>dst<span class="token punctuation">)</span>plt<span class="token punctuation">.</span>show<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/pic/%E9%80%89%E5%8C%BA_024.png" alt="仿射变换结果"></p><blockquote><p>射影变换:次坐标的一般非奇异线性变换 。射影变换可以分解为相似变换，仿射变换，射影变换的复合，不保留平行性，保留重合关系、长度的交比</p></blockquote><p><img src="/pic/%E9%80%89%E5%8C%BA_026.png" alt="射影变换矩阵"></p><p>它左上角为可逆矩阵 A，右上为平移 t，左下缩放 a^{T} 。由于采用齐坐标，当 v \neq 0 时吗我们可以对整个矩阵除于 v得到一个右下角为 1 的矩阵；否则，则得到右下角为 0 的矩阵。因此，2D 的射影变换一共有8个自由度，3D则共有15个自由度。</p><ul><li>性质：Lines are still lines（不保角，不保平行，保直线性）</li><li>四个非共线的点对（8 parameters）确定一个透视变换</li></ul><p><img src="/pic/%E9%80%89%E5%8C%BA_023.png" alt="射影变换矩阵"></p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> cv2<span class="token keyword">import</span> matplotlib<span class="token punctuation">.</span>pyplot <span class="token keyword">as</span> plt<span class="token keyword">import</span> numpy <span class="token keyword">as</span> npimg <span class="token operator">=</span> cv2<span class="token punctuation">.</span>imread<span class="token punctuation">(</span><span class="token string">'lenna.jpg'</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>img <span class="token operator">=</span> cv2<span class="token punctuation">.</span>cvtColor<span class="token punctuation">(</span>img<span class="token punctuation">,</span> cv2<span class="token punctuation">.</span>COLOR_BGR2RGB<span class="token punctuation">)</span>width <span class="token operator">=</span> img<span class="token punctuation">.</span>shape<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>height <span class="token operator">=</span> img<span class="token punctuation">.</span>shape<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>pts1 <span class="token operator">=</span> np<span class="token punctuation">.</span>float32<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>width<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span>height<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>width<span class="token punctuation">,</span>height<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span>pts2 <span class="token operator">=</span> np<span class="token punctuation">.</span>float32<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">[</span>width<span class="token operator">*</span><span class="token number">0.1</span><span class="token punctuation">,</span>height<span class="token operator">*</span><span class="token number">0.1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>width<span class="token operator">*</span><span class="token number">0.9</span><span class="token punctuation">,</span> width<span class="token operator">*</span><span class="token number">0.1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>height<span class="token operator">*</span><span class="token number">0.2</span><span class="token punctuation">,</span>height<span class="token operator">*</span><span class="token number">0.8</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>width<span class="token operator">*</span><span class="token number">0.7</span><span class="token punctuation">,</span>height<span class="token operator">*</span><span class="token number">0.7</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span>M_warp <span class="token operator">=</span> cv2<span class="token punctuation">.</span>getPerspectiveTransform<span class="token punctuation">(</span>pts1<span class="token punctuation">,</span> pts2<span class="token punctuation">)</span>     <span class="token comment"># 单应性矩阵</span>img_warp <span class="token operator">=</span> cv2<span class="token punctuation">.</span>warpPerspective<span class="token punctuation">(</span>img<span class="token punctuation">,</span> M_warp<span class="token punctuation">,</span> <span class="token punctuation">(</span>width<span class="token punctuation">,</span> height<span class="token punctuation">)</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>figure<span class="token punctuation">(</span>figsize<span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>subplot<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>imshow<span class="token punctuation">(</span>img<span class="token punctuation">)</span>plt<span class="token punctuation">.</span>subplot<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>imshow<span class="token punctuation">(</span>img_warp<span class="token punctuation">)</span>plt<span class="token punctuation">.</span>show<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/pic/%E9%80%89%E5%8C%BA_025.png" alt="射影变换结果"></p>]]></content>
      
      
      <categories>
          
          <category> cs231A </category>
          
      </categories>
      
      
        <tags>
            
            <tag> transformer </tag>
            
            <tag> opencv </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>对极几何(Epipolar_Geometry)</title>
      <link href="/2023/03/27/epipolar-geometry/"/>
      <url>/2023/03/27/epipolar-geometry/</url>
      
        <content type="html"><![CDATA[<h1 id="对极几何基本用处"><a href="#对极几何基本用处" class="headerlink" title="对极几何基本用处"></a>对极几何基本用处</h1><h2 id="立体匹配"><a href="#立体匹配" class="headerlink" title="立体匹配"></a>立体匹配</h2><p>对于已知两视角空间位置关系的情况下，由于对极几何这个几何模型限定的约束条件，使得在立体图像对上搜索空间上的分别在两个图像中的位置只需要相应的对极线上找，把原来的二维搜搜问题，直接简化为一维搜索，双目测距就是这方面得应用之一。</p><h2 id="确定两个摄像点的相对位置与姿态问题"><a href="#确定两个摄像点的相对位置与姿态问题" class="headerlink" title="确定两个摄像点的相对位置与姿态问题"></a>确定两个摄像点的相对位置与姿态问题</h2><p>在未知视角位置的情况下，通过搜索图像对中的匹配点，可以求得两个位置和姿态得相对关系，这一点常用在机器人导航、地图得生成、三维重建等方面。</p><blockquote><p>基本概念</p></blockquote><ul><li>极点（Epipoles）：两个相机得基线与两个成像平面得交点</li><li>极线（Epipolar Lines）：空间中点在成像平面上的投影点与极点的连线</li><li>极平面（Epipolar Plane）：空间中的点与两个相机的光轴中心点所组成的平面</li></ul><blockquote><p>本质矩阵</p></blockquote><p><img src="/pic/duiji2.png"></p><blockquote><p>对极约束(E)</p></blockquote><p><img src="/pic/duiji.png"></p><blockquote><p>基础矩阵</p></blockquote><p><img src="/pic/duiji3.png"></p><blockquote><p>对极约束(F)</p></blockquote><p><img src="/pic/duiji4.png"></p>]]></content>
      
      
      <categories>
          
          <category> cs231A </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 对极几何 </tag>
            
            <tag> 对极约束 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git 基础用法</title>
      <link href="/2023/03/26/git/"/>
      <url>/2023/03/26/git/</url>
      
        <content type="html"><![CDATA[<h1 id="Git介绍"><a href="#Git介绍" class="headerlink" title="Git介绍"></a>Git介绍</h1><p>Git是一个开源的<strong>分布式版本控制系统</strong>，可以有效、高速地处理从很小到非常大的项目版本管理。也是Linus Torvalds为了帮助管理Linux内核开发而开发的一个开放源码的版本控制软件。与常用的版本控制工具<strong>CVS, Subversion</strong>等不同，它采用了<strong>分布式版本库</strong>的方式，不必服务器端软件支持（wingeddevil注：这得分是用什么样的服务端，使用http协议或者git协议等不太一样。并且在push和pull的时候和服务器端还是有交互的。），使源代码的发布和交流极其方便。 Git 的速度很快，这对于诸如 Linux kernel 这样的大项目来说自然很重要。 Git 最为出色的是它的合并跟踪（merge tracing）能力。</p><p>Torvalds 开始着手开发 Git 是为了作为一种过渡方案来替代 BitKeeper</p><p><em>分布式相比于集中式的最大区别在于开发者可以提交到本地，每个开发者通过克隆（git clone），在本地机器上拷贝一个完整的Git仓库</em></p><h2 id="Git基本工作过程"><a href="#Git基本工作过程" class="headerlink" title="Git基本工作过程"></a>Git基本工作过程</h2><blockquote><p>9个常见操作，具体如下</p></blockquote><ul><li><p>1.新建项目文件夹（只做一次）</p></li><li><p>2.进入文件夹 (重要)</p></li><li><p>3.初始化仓库：git init（只做一次）</p></li><li><p>4.编码</p></li><li><p>5.添加文件信息： git add .</p></li><li><p>6.确认添加信息：git commit -m”描述信息”</p></li><li><p>7.查看详细日志信息：git log</p></li><li><p>8.查看简略日志信息：git log –oneline</p></li><li><p>9.版本回滚:git reset –hard 版本号</p></li></ul><img src="/pic/git.png"><h2 id="其他的常用操作"><a href="#其他的常用操作" class="headerlink" title="其他的常用操作"></a>其他的常用操作</h2><h3 id="git-init"><a href="#git-init" class="headerlink" title="git init"></a>git init</h3><blockquote><p>用法：git clone [url]</p></blockquote><p>该命令可用于通过指定的URL获取一个代码库。</p><h3 id="git-config"><a href="#git-config" class="headerlink" title="git config"></a>git config</h3><blockquote><p>用法：git config –global user.name “[name]”</p></blockquote><blockquote><p>用法：git config –global user.email “[email address]”</p></blockquote><p>该命令将分别设置提交代码的用户名和电子邮件地址。</p><h3 id="git-add"><a href="#git-add" class="headerlink" title="git add"></a>git add</h3><blockquote><p>用法：git add [file]</p></blockquote><p>该命令可以将一个文件添加至stage(暂存区)。</p><blockquote><p>用法：git add *</p></blockquote><p>该命令可以将多个文件添加至stage(暂存区)。</p><h3 id="git-commit"><a href="#git-commit" class="headerlink" title="git commit"></a>git commit</h3><blockquote><p>用法：git commit -m “[ Type in the commit message]”</p></blockquote><p>该命令可以在版本历史记录中永久记录文件。</p><blockquote><p>用法：git commit -a</p></blockquote><p>该命令将提交git add命令添加的所有文件，并提交git add命令之后更改的所有文件。 </p><h3 id="git-diff"><a href="#git-diff" class="headerlink" title="git diff"></a>git diff</h3><blockquote><p>用法：git diff</p></blockquote><p>该命令可以显示尚未添加到stage的文件的变更。</p><blockquote><p>用法：git diff –staged</p></blockquote><p>该命令可以显示添加到stage的文件与当前最新版本之间的差异。</p><blockquote><p>用法：git diff [first branch] [second branch]</p></blockquote><p>该命令可以显示两个分支之间的差异。</p><h3 id="git-reset"><a href="#git-reset" class="headerlink" title="git reset"></a>git reset</h3><blockquote><p>用法：git reset [file]</p></blockquote><p>该命令将从stage中撤出指定的文件，但可以保留文件的内容。</p><blockquote><p>用法：git reset [commit]</p></blockquote><p>该命令可以撤销指定提交之后的所有提交，并在本地保留变更。</p><h3 id="git-status"><a href="#git-status" class="headerlink" title="git status"></a>git status</h3><blockquote><p>用法：git status</p></blockquote><p>该命令将显示所有需要提交的文件。</p><h3 id="git-rm"><a href="#git-rm" class="headerlink" title="git rm"></a>git rm</h3><blockquote><p>用法：git rm [file]</p></blockquote><p>该命令将删除工作目录中的文件，并将删除动作添加到stage。</p><h3 id="git-log"><a href="#git-log" class="headerlink" title="git log"></a>git log</h3><blockquote><p>用法：git log</p></blockquote><p>该命令可用于显示当前分支的版本历史记录。</p><blockquote><p>用法：git log –follow[file]</p></blockquote><p>该命令可用于显示某个文件的版本历史记录，包括文件的重命名。</p><h3 id="git-show"><a href="#git-show" class="headerlink" title="git show"></a>git show</h3><blockquote><p>用法：git show [commit]</p></blockquote><p>该命令经显示指定提交的元数据以及内容变更。</p><h3 id="git-tag"><a href="#git-tag" class="headerlink" title="git tag"></a>git tag</h3><blockquote><p>用法：git tag [commitID]</p></blockquote><p>该命令可以给指定的提交添加标签。</p><h3 id="git-branch"><a href="#git-branch" class="headerlink" title="git branch"></a>git branch</h3><blockquote><p>用法：git branch</p></blockquote><p>该命令将显示当前代码库中所有的本地分支。</p><blockquote><p>用法：git branch [branch name]</p></blockquote><p>该命令将创建一个分支。</p><blockquote><p>用法：git branch -d [branch name]</p></blockquote><p>该命令将删除指定的分支。</p><h3 id="git-checkout"><a href="#git-checkout" class="headerlink" title="git checkout"></a>git checkout</h3><blockquote><p>用法：git checkout [branch name]</p></blockquote><p>你可以通过该命令切换分支。</p><blockquote><p>用法：git checkout -b [branch name]</p></blockquote><p>你可以通过该命令创建一个分支，并切换到新分支上。</p><h3 id="git-merge"><a href="#git-merge" class="headerlink" title="git merge"></a>git merge</h3><blockquote><p>用法：git merge [branch name]</p></blockquote><p>该命令可以将指定分支的历史记录合并到当前分支。</p><h3 id="git-remote"><a href="#git-remote" class="headerlink" title="git remote"></a>git remote</h3><blockquote><p>用法：git remote add [variable name] [Remote Server Link]</p></blockquote><p>你可以通过该命令将本地的代码库连接到远程服务器。</p><h3 id="git-push"><a href="#git-push" class="headerlink" title="git push"></a>git push</h3><blockquote><p>用法：git push [variable name] master</p></blockquote><p>该命令可以将主分支上提交的变更发送到远程代码库。</p><blockquote><p>用法：git push [variable name] [branch]</p></blockquote><p>该命令可以将指定分支上的提交发送到远程代码库。</p><blockquote><p>用法：git push –all [variable name]</p></blockquote><p>该命令可以将所有分支发送到远程代码库。</p><blockquote><p>用法：git pull [Repository Link]</p></blockquote><p>该命令将获取远程服务器上的变更，并合并到你的工作目录。</p><h3 id="git-stash"><a href="#git-stash" class="headerlink" title="git stash"></a>git stash</h3><blockquote><p>用法：git stash save</p></blockquote><p>该命令将临时保存所有修改的文件。</p><blockquote><p>用法：git stash pop</p></blockquote><p>该命令将恢复最近一次stash（储藏）的文件。</p><blockquote><p>用法：git stash list</p></blockquote><p>该命令将显示stash的所有变更。</p><blockquote><p>用法：git stash drop</p></blockquote><p>该命令将丢弃最近一次stash的变更。</p><h2 id="Git小游戏"><a href="#Git小游戏" class="headerlink" title="Git小游戏"></a>Git小游戏</h2><p>游戏链接为<a href="https://oschina.gitee.io/learn-git-branching/">GIt小游戏</a></p><p>推荐一个图解答案<a href="https://blog.csdn.net/GDUT_xin/article/details/125537967">答案</a></p><pre class="line-numbers language-none"><code class="language-none">---基础篇1.git commitgit commitgit commit2.git branchgit branch bugFixgit checkout bugFix3.git mergegit branch bugFixgit checkout bugFixgit commit -m “commit bugFix”git checkout maingit commit -m “commit main”git merge bugFix4.git rebasegit branch bugFixgit checkout bugFixgit commit -m “bugFix”git checkout maingit commit -m “main commit”git checkout bugFixgit rebase main高级篇1.分离HEADgit checkout c42.相对引用(^)git checkout main^git checkout c33.相对引用2(~)git branch -f main c6git checkout HEAD~1git branch -f bugFix HEAD~14.撤销变更git reset HEAD~1git chekout pushedgit revert HEAD移动提交记录1.git cherry-pickgit cherry-pick c3 c4 c72.交互式rebasegit rebase -i overHere （打开控制面板）omit c2 （点击c2）c4 c5交换位置 （拉取）杂项1.只取一个提交记录git checkout maingit cherry-pick c42.提交的技巧#1git rebase -i HEAD~2 交换2和3的位置git commit --amendgit rebase -i HEAD~2 恢复2和3的位置git checkout miangit rebase caption main3.提交的技巧#2git checkout maingit cherry-pick c2git commit --amendgit cherry-pick c34.git taggit tag v0 c1git tag v1 c2git checkout c25. git descridegit commit高级话题1.多次rebasegit rebase main bugFixgit rebase bugFix sidegit rebase side anothergit rebase another main2.两个父节点git branch bugWork main^ ^ 2^3.纠缠不清的分支git checkout onegit cherry-pick c4 c3 c2git checkout twogit cherry-pick c5 c4 c3 c2git branch -f three c2Push &amp; Pull —— Git 远程仓库！1.git clonegit clone2.远程分支git commitgit checkout o&#x2F;maingit commit3.git fetchgit fetch4.git pullgit pull5.模拟团队合作git clonegit fakeTeamwork 2git commitgit pull6.git pushgit commitgit commitgit push7.偏离的提及历史git clonegit fakeTeamworkgit commitgit pull --rebasegit push8.锁定的main（locked main）git reset --hard o&#x2F;maingit checkout -b feature c2git push origin feature关于 origin 和它的周边 —— Git 远程仓库高级操作1.推送主分支git fetchgit rebase o&#x2F;main side1git rebase side1 side2git rebase side2 side3git rebase side3 maingit push2.合并远程仓库git checkout maingit pullgit merge side1git merge side2git merge side3git push3.远程追踪git checkout -b side o&#x2F;maingit commitgit pull --rebasegit push4.git push的参数git push origin maingit push origin foo5.git push的参数2git push origin main^:foogit push origin foo:main6.git fetch的参数git fetch origin main~1:foogit fetch origin foo:maingit checkout foogit merge main7.没有source的sourcegit fetch origin :bargit push origin :foo8.git pull的参数git pull origin bar:foogit pull origin main:side---<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>你好</title>
      <link href="/2023/03/25/chy/"/>
      <url>/2023/03/25/chy/</url>
      
        <content type="html"><![CDATA[<h1 id="hexo-theme-matery"><a href="#hexo-theme-matery" class="headerlink" title="hexo-theme-matery"></a>hexo-theme-matery</h1><p><a href="http://hits.dwyl.io/blinkfox/hexo-theme-matery"><img src="http://hits.dwyl.io/blinkfox/hexo-theme-matery.svg" alt="HitCount"></a> <a href="https://gitter.im/hexo-theme-matery/Lobby?utm_source=badge"><img src="https://img.shields.io/gitter/room/blinkfox/hexo-theme-matery.svg" alt="Gitter"></a> <a href="https://github.com/blinkfox/hexo-theme-matery/issues"><img src="https://img.shields.io/github/issues/blinkfox/hexo-theme-matery.svg" alt="GitHub issues"></a> <a href="https://github.com/blinkfox/hexo-theme-matery/blob/master/LICENSE"><img src="https://img.shields.io/github/license/blinkfox/hexo-theme-matery.svg" alt="GitHub license"></a> <a href="https://codeload.github.com/blinkfox/hexo-theme-matery/zip/master"><img src="https://img.shields.io/badge/downloads-master-green.svg" alt="Download"></a> <a href="http://hexo.io/"><img src="https://img.shields.io/badge/hexo-%3E%3D%205.0.0-blue.svg" alt="Hexo Version"></a> <a href="https://github.com/blinkfox/hexo-theme-matery/network"><img src="https://img.shields.io/github/forks/blinkfox/hexo-theme-matery.svg" alt="GitHub forks"></a> <a href="https://github.com/blinkfox/hexo-theme-matery/stargazers"><img src="https://img.shields.io/github/stars/blinkfox/hexo-theme-matery.svg" alt="GitHub stars"></a></p><p><a href="README.md">🇺🇸English Document</a> | <a href="http://blinkfox.com/">国内访问示例 (http://blinkfox.com)</a> | <a href="https://blinkfox.github.io/">Github 部署演示示例 (https://blinkfox.github.io)</a> </p><p>QQ 交流群1（已满）: <a href="https://jq.qq.com/?_wv=1027&k=5zMDYHT"><code>926552981</code></a> | QQ 交流群2（已满）: <a href="https://jq.qq.com/?_wv=1027&k=53q2Ayp"><code>971887688</code></a> | QQ 交流群3（推荐）: <a href="https://qm.qq.com/cgi-bin/qm/qr?k=fC1-kU-_aTn4q-JQq4GsYKr4WcKdgfGa&jump_from=webapi"><code>670694035</code></a></p><blockquote><p>这是一个采用 <code>Material Design</code> 和响应式设计的 Hexo 博客主题。</p></blockquote><h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><ul><li>简单漂亮，文章内容美观易读</li><li><a href="https://material.io/">Material Design</a> 设计</li><li>响应式设计，博客在桌面端、平板、手机等设备上均能很好的展现</li><li>首页轮播文章及每天动态切换 <code>Banner</code> 图片</li><li>瀑布流式的博客文章列表（文章无特色图片时会有 <code>24</code> 张漂亮的图片代替）</li><li>时间轴式的归档页</li><li><strong>词云</strong>的标签页和<strong>雷达图</strong>的分类页</li><li>丰富的关于我页面（包括关于我、文章统计图、我的项目、我的技能、相册等）</li><li>可自定义的数据的友情链接页面</li><li>支持文章置顶和文章打赏</li><li>支持 <code>MathJax</code></li><li>支持中文繁简转换</li><li><code>TOC</code> 目录</li><li>可设置复制文章内容时追加版权信息</li><li>可设置阅读文章时做密码验证</li><li><a href="https://gitalk.github.io/">Gitalk</a>、<a href="https://imsun.github.io/gitment/">Gitment</a>、<a href="https://valine.js.org/">Valine</a> 和 <a href="https://disqus.com/">Disqus</a> 评论模块（推荐使用 <code>Gitalk</code>）</li><li>集成了<a href="http://busuanzi.ibruce.info/">不蒜子统计</a>、谷歌分析（<code>Google Analytics</code>）和文章字数统计等功能</li><li>支持在首页的音乐播放和视频播放功能</li><li>支持<code>emoji</code>表情，用<code>markdown emoji</code>语法书写直接生成对应的能<strong>跳跃</strong>的表情。</li><li>支持 <a href="http://www.daovoice.io/">DaoVoice</a>、<a href="https://www.tidio.com/">Tidio</a> 在线聊天功能。</li></ul><table><thead><tr><th>表头</th><th>表头</th></tr></thead><tbody><tr><td>单元格</td><td>单元格</td></tr><tr><td>单元格</td><td>单元格</td></tr></tbody></table><table><thead><tr><th align="left">左对齐</th><th align="right">右对齐</th><th align="center">居中对齐</th></tr></thead><tbody><tr><td align="left">单元格</td><td align="right">单元格</td><td align="center">单元格</td></tr><tr><td align="left">单元格</td><td align="right">单元格</td><td align="center">单元格</td></tr></tbody></table><h2 id="贡献者"><a href="#贡献者" class="headerlink" title="贡献者"></a>贡献者</h2><p>感谢下面列出的贡献者，没有他们，hexo-theme-matery 不会这么完美。</p><ul><li><a href="https://github.com/HarborZeng">@HarborZeng</a></li><li><a href="https://github.com/shw2018">@shw2018</a></li><li><a href="https://github.com/L1cardo">@L1cardo</a></li><li><a href="https://github.com/Five-great">@Five-great</a></li></ul><h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><p>本主题<strong>推荐你使用 Hexo 5.0.0 及以上的版本</strong>。如果，你已经有一个自己的 <a href="https://hexo.io/zh-cn/">Hexo</a> 博客了，建议你将 Hexo 升级到最新稳定的版本。</p><p>点击 <a href="https://codeload.github.com/blinkfox/hexo-theme-matery/zip/master">这里</a> 下载 <code>master</code> 分支的最新稳定版的代码，解压缩后，将 <code>hexo-theme-matery</code> 的文件夹复制到你 Hexo 的 <code>themes</code> 文件夹中即可。</p><p>当然你也可以在你的 <code>themes</code> 文件夹下使用 <code>git clone</code> 命令来下载:</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> clone https://github.com/blinkfox/hexo-theme-matery.git<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><h3 id="切换主题"><a href="#切换主题" class="headerlink" title="切换主题"></a>切换主题</h3><p>修改 Hexo 根目录下的 <code>_config.yml</code> 的  <code>theme</code> 的值：<code>theme: hexo-theme-matery</code></p><h4 id="config-yml-文件的其它修改建议"><a href="#config-yml-文件的其它修改建议" class="headerlink" title="_config.yml 文件的其它修改建议:"></a><code>_config.yml</code> 文件的其它修改建议:</h4><ul><li>请修改 <code>_config.yml</code> 的 <code>url</code> 的值为你的网站主 <code>URL</code>（如：<code>http://xxx.github.io</code>）。</li><li>建议修改两个 <code>per_page</code> 的分页条数值为 <code>6</code> 的倍数，如：<code>12</code>、<code>18</code> 等，这样文章列表在各个屏幕下都能较好的显示。</li><li>如果你是中文用户，则建议修改 <code>language</code> 的值为 <code>zh-CN</code>。</li></ul><h3 id="新建分类-categories-页"><a href="#新建分类-categories-页" class="headerlink" title="新建分类 categories 页"></a>新建分类 categories 页</h3><p><code>categories</code> 页是用来展示所有分类的页面，如果在你的博客 <code>source</code> 目录下还没有 <code>categories/index.md</code> 文件，那么你就需要新建一个，命令如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">hexo new page <span class="token string">"categories"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>编辑你刚刚新建的页面文件 <code>/source/categories/index.md</code>，至少需要以下内容：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token punctuation">---</span><span class="token key atrule">title</span><span class="token punctuation">:</span> categories<span class="token key atrule">date</span><span class="token punctuation">:</span> <span class="token datetime number">2018-09-30 17:25:30</span><span class="token key atrule">type</span><span class="token punctuation">:</span> <span class="token string">"categories"</span><span class="token key atrule">layout</span><span class="token punctuation">:</span> <span class="token string">"categories"</span><span class="token punctuation">---</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2023/03/23/hello-world/"/>
      <url>/2023/03/23/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo generate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo deploy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
